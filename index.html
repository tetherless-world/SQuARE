<h1 id="a-validation-ontology-for-evaluating-semantic-reasoning-engines-">A Validation Ontology for Evaluating Semantic Reasoning Engines*</h1>
<p>*This work is partially supported by IBM Research through the AI Horizons Network.</p>
<h3 id="abstract">Abstract</h3>
<p>We describe an approach for building a deductive inference engine by encoding each OWL Description Logic (DL) axiom as a SPARQL CONSTRUCT query. While earlier work has proposed SPARQL extensions for various purposes, we find that the complete queries used in SPARQL-based reasoning methods are not publicly available. We were also unable to find a similar approach in the literature in which the OWL DL axioms are represented as SPARQL CONSTRUCT queries. We make openly available the queries, software, and the validation ontology that we use for our methodology. Encoded in this validation ontology are RDF examples for each OWL-DL axiom, allowing for the testing of our reasoning engine at a per axiom basis. We describe our approach in terms of implementation, query formulation, and validation. We evaluate the extent to which we are able to encode DL axioms and discuss the implications of the results. We further discuss future research directions that we are pursuing. The approach described in this paper has benefits related to inference engine customization capabilities and of being able to reason over inconsistent knowledge. This work is motivated by potential applications involving hybrid reasoning, distributed reasoning, and explainability in reasoning by embedding provenance in the form of nanopublications.</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#a-validation-ontology-for-evaluating-semantic-reasoning-engines-">Home</a><ul>
<li><a href="#abstract">Abstract</a><ul>
<li><a href="#resources">Resources</a></li>
</ul>
</li>
<li><a href="#ontology">Ontology</a></li>
<li><a href="#sparql-construct-axioms">SPARQL CONSTRUCT Axioms</a></li>
<li><a href="#inclusion">Inclusion</a><ul>
<li><a href="#class-inclusion">Class Inclusion</a></li>
<li><a href="#individual-inclusion">Individual Inclusion</a></li>
<li><a href="#property-inclusion">Property Inclusion</a><ul>
<li><a href="#object-property-inclusion">Object Property Inclusion</a></li>
<li><a href="#data-property-inclusion">Data Property Inclusion</a></li>
</ul>
</li>
<li><a href="#object-property-chain-inclusion">Object Property Chain Inclusion</a></li>
</ul>
</li>
<li><a href="#equivalence">Equivalence</a><ul>
<li><a href="#class-equivalence">Class Equivalence</a></li>
<li><a href="#property-equivalence">Property Equivalence</a></li>
</ul>
</li>
<li><a href="#disjointness">Disjointness</a><ul>
<li><a href="#class-disjointness">Class Disjointness</a></li>
<li><a href="#property-disjointness">Property Disjointness</a></li>
<li><a href="#all-disjoint-classes">All Disjoint Classes</a></li>
<li><a href="#all-disjoint-properties">All Disjoint Properties</a></li>
</ul>
</li>
<li><a href="#transitivity">Transitivity</a><ul>
<li><a href="#object-property-transitivity">Object Property Transitivity</a></li>
</ul>
</li>
<li><a href="#reflexivity">Reflexivity</a><ul>
<li><a href="#object-property-reflexivity">Object Property Reflexivity</a></li>
<li><a href="#object-property-irreflexivity">Object Property Irreflexivity</a></li>
</ul>
</li>
<li><a href="#symmetry">Symmetry</a><ul>
<li><a href="#object-property-symmetry">Object Property Symmetry</a></li>
<li><a href="#object-property-asymmetry">Object Property Asymmetry</a></li>
</ul>
</li>
<li><a href="#functionality">Functionality</a><ul>
<li><a href="#functional-object-property">Functional Object Property</a></li>
<li><a href="#functional-data-property">Functional Data Property</a></li>
</ul>
</li>
<li><a href="#inversion">Inversion</a><ul>
<li><a href="#object-property-inversion">Object Property Inversion</a><ul>
<li><a href="#inverse-functional-object-property">Inverse Functional Object Property</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#domain-&amp;-range-restrictions">Domain &amp; Range Restrictions</a><ul>
<li><a href="#domain-restriction">Domain Restriction</a></li>
<li><a href="#range-restriction">Range Restriction</a></li>
</ul>
</li>
<li><a href="#datatype">Datatype</a><ul>
<li><a href="#datatype-restriction">Datatype Restriction</a></li>
</ul>
</li>
<li><a href="#assertions">Assertions</a><ul>
<li><a href="#same-individual">Same Individual</a></li>
<li><a href="#different-individuals">Different Individuals</a></li>
<li><a href="#all-different-individuals">All Different Individuals</a></li>
<li><a href="#class-assertion">Class Assertion</a></li>
<li><a href="#property-assertion">Property Assertion</a><ul>
<li><a href="#object-property-assertion">Object Property Assertion</a></li>
<li><a href="#data-property-assertion">Data Property Assertion</a></li>
<li><a href="#negative-object-property-assertion">Negative Object Property Assertion</a></li>
<li><a href="#negative-data-property-assertion">Negative Data Property Assertion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#keys">Keys</a></li>
<li><a href="#existential-quantification">Existential Quantification</a><ul>
<li><a href="#object-some-values-from">Object Some Values From</a></li>
<li><a href="#data-some-values-from">Data Some Values From</a></li>
<li><a href="#object-has-value">Object Has Value</a></li>
<li><a href="#data-has-value">Data Has Value</a></li>
</ul>
</li>
<li><a href="#universal-quantification">Universal Quantification</a><ul>
<li><a href="#object-all-values-from">Object All Values From</a></li>
<li><a href="#data-all-values-from">Data All Values From</a></li>
</ul>
</li>
<li><a href="#self-restriction">Self Restriction</a><ul>
<li><a href="#object-has-self">Object Has Self</a></li>
</ul>
</li>
<li><a href="#individual-enumeration">Individual Enumeration</a><ul>
<li><a href="#object-one-of">Object One Of</a><ul>
<li><a href="#object-one-of-membership">Object One Of Membership</a></li>
<li><a href="#object-one-of-inconsistency">Object One Of Inconsistency</a></li>
</ul>
</li>
<li><a href="#data-one-of">Data One Of</a></li>
</ul>
</li>
<li><a href="#cardinality">Cardinality</a><ul>
<li><a href="#max-cardinality">Max Cardinality</a><ul>
<li><a href="#object-max-cardinality">Object Max Cardinality</a></li>
<li><a href="#data-max-cardinality">Data Max Cardinality</a></li>
<li><a href="#object-max-qualified-cardinality">Object Max Qualified Cardinality</a></li>
<li><a href="#data-max-qualified-cardinality">Data Max Qualified Cardinality</a></li>
</ul>
</li>
<li><a href="#min-cardinality">Min Cardinality</a><ul>
<li><a href="#object-min-cardinality">Object Min Cardinality</a></li>
<li><a href="#data-min-cardinality">Data Min Cardinality</a></li>
<li><a href="#object-min-qualified-cardinality">Object Min Qualified Cardinality</a></li>
<li><a href="#data-min-qualified-cardinality">Data Min Qualified Cardinality</a></li>
</ul>
</li>
<li><a href="#exact-cardinality">Exact Cardinality</a><ul>
<li><a href="#object-exact-cardinality">Object Exact Cardinality</a></li>
<li><a href="#data-exact-cardinality">Data Exact Cardinality</a></li>
<li><a href="#object-exact-qualified-cardinality">Object Exact Qualified Cardinality</a></li>
<li><a href="#data-exact-qualified-cardinality">Data Exact Qualified Cardinality</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#disjunction">Disjunction</a><ul>
<li><a href="#object-union-of">Object Union Of</a></li>
<li><a href="#data-union-of">Data Union Of</a></li>
<li><a href="#disjoint-union">Disjoint Union</a></li>
</ul>
</li>
<li><a href="#intersection">Intersection</a><ul>
<li><a href="#object-intersection-of">Object Intersection Of</a></li>
<li><a href="#data-intersection-of">Data Intersection Of</a></li>
</ul>
</li>
<li><a href="#negation">Negation</a><ul>
<li><a href="#complement-of">Complement Of</a><ul>
<li><a href="#object-complement-of">Object Complement Of</a></li>
<li><a href="#data-complement-of">Data Complement Of</a></li>
<li><a href="#object-property-complement-of">Object Property Complement Of</a></li>
<li><a href="#data-property-complement-of">Data Property Complement Of</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#code">Code</a><ul>
<li><a href="#deductor-agent">Deductor Agent</a></li>
<li><a href="#backtracer-agent">Backtracer Agent</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="resources">Resources</h2>
<h3 id="ontology">Ontology</h3>
<p>The documentation for the ontology is available <a href="documentation.html">here</a>.</p>
<p>The consistent version of the ontology is available <a href="https://raw.githubusercontent.com/tetherless-world/validation/main/valo.ttl">here</a>.</p>
<p>The inconsistent version of the ontology is available <a href="https://raw.githubusercontent.com/tetherless-world/validation/main/valo_inconsistent.ttl">here</a>.</p>
<h3 id="sparql-construct-axioms">SPARQL CONSTRUCT Axioms</h3>
<h3 id="inclusion">Inclusion</h3>
<h4 id="class-inclusion">Class Inclusion</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C_1%20\sqsubseteq%20C_2" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdfs:subClassOf ?superClass .
}
WHERE {
  ?resource rdfs:subClassOf ?class .
  ?class rdfs:subClassOf+ ?superClass .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is a subclass of <em>superClass</em>, any class that is a subclass of <em>class</em> is also a subclass of <em>superClass</em>. Therefore, <em>resource</em> is a subclass of <em>superClass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Entity rdf:type owl:Class ;
    rdfs:label &quot;entity&quot; ;
    dct:description &quot;Every thing is an entity.&quot; .

sio:Object rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;object&quot; ;
    #&lt;rdfs:subClassOf rdf:nodeID=&quot;arc703eb381&quot;/&gt;
    dct:description &quot;An object is an entity that is wholly identifiable at any instant of time during which it exists.&quot; .

sio:MaterialEntity  rdf:type owl:Class ;
    rdfs:label &quot;material entity&quot; ;
    rdfs:subClassOf sio:Object ;
    dct:description &quot;A material entity is a physical entity that is spatially extended, exists as a whole at any point in time and has mass.&quot; .
</code></pre><p>A reasoner should infer <code>sio:MaterialEntity rdfs:subClassOf sio:Entity .</code> </p>
<h4 id="individual-inclusion">Individual Inclusion</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=a:C" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?superClass .
}
WHERE {
  ?resource rdf:type ?class .
  ?class rdfs:subClassOf+ ?superClass .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Any instance of <em>class</em> is also an instance of <em>superClass</em>. Therefore, since <em>resource</em> is a <em>class</em>, it also is a <em>superClass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Role rdf:type owl:Class ;
    rdfs:label &quot;role&quot; ;
    rdfs:subClassOf sio:RealizableEntity ;
    dct:description &quot;A role is a realizable entity that describes behaviours, rights and obligations of an entity in some particular circumstance.&quot; .

val-kb:Farmer rdf:type sio:Role ;
    rdfs:label &quot;farmer&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Farmer rdf:type sio:RealizableEntity .</code></p>
<h4 id="property-inclusion">Property Inclusion</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=P_1%20\sqsubseteq%20P_2" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?superProperty ?o .
}
WHERE {
  ?resource ?p ?o .
  ?p rdf:type owl:Property ;
    rdfs:subPropertyOf+ ?superProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Any subject and object related by the property _p_ is also related by <em>superProperty</em>. Therefore, since <em>resource</em> _p_ _o_, it is implied that <em>resource</em> <em>superProperty</em> _o_.</p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><p>A reasoner should infer <code></code></p>
<h5 id="object-property-inclusion">Object Property Inclusion</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?superProperty ?o .
}
WHERE {
  ?resource ?p ?o .
  ?p rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf+ ?superProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Any subject and object related by the property _p_ is also related by <em>superProperty</em>. Therefore, since <em>resource</em> _p_ _o_, it is implied that <em>resource</em> <em>superProperty</em> _o_.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Age rdf:type owl:Class ;
    rdfs:label &quot;age&quot; ;
    rdfs:subClassOf sio:DimensionalQuantity ;
    dct:description &quot;Age is the length of time that a person has lived or a thing has existed.&quot; .

sio:DimensionlessQuantity rdf:type owl:Class ;
    rdfs:label &quot;dimensionless quantity&quot; ;
    rdfs:subClassOf sio:Quantity ,
        [ rdf:type owl:Class ;
            owl:complementOf [ rdf:type owl:Restriction ;
                owl:onProperty sio:hasUnit ;
                owl:someValuesFrom sio:UnitOfMeasurement ] ];
    owl:disjointWith sio:DimensionalQuantity ;
    dct:description &quot;A dimensionless quantity is a quantity that has no associated unit.&quot; .

sio:Quantity rdf:type owl:Class ;
    rdfs:label &quot;quantity&quot; ;
    owl:equivalentClass 
        [ rdf:type owl:Class ; 
            owl:unionOf (sio:DimensionlessQuantity sio:DimensionalQuantity) ] ;
    rdfs:subClassOf sio:MeasurementValue ;
    dct:description &quot;A quantity is an informational entity that gives the magnitude of a property.&quot; .

sio:MeasurementValue rdf:type owl:Class ;
    rdfs:label &quot;measurement value&quot; ;
    rdfs:subClassOf sio:Number ;
    dct:description &quot;A measurement value is a quantitative description that reflects the magnitude of some attribute.&quot; .

sio:Number rdf:type owl:Class ;
    rdfs:label &quot;number&quot; ;
    rdfs:subClassOf sio:MathematicalEntity ;
    dct:description &quot;A number is a mathematical object used to count, label, and measure.&quot; .

val-kb:Samantha sio:hasProperty val-kb:AgeOfSamantha .

val-kb:AgeOfSamantha rdf:type sio:Age ;
    rdfs:label &quot;Samantha&#39;s age&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Samantha sio:hasAttribute val-kb:AgeOfSamantha .</code></p>
<h5 id="data-property-inclusion">Data Property Inclusion</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?superProperty ?o .
}
WHERE {
  ?resource ?p ?o .
  ?p rdf:type owl:DatatypeProperty ;
    rdfs:subPropertyOf+ ?superProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Any subject and object related by the property _p_ is also related by <em>superProperty</em>. Therefore, since <em>resource</em> _p_ _o_, it is implied that <em>resource</em> <em>superProperty</em> _o_.</p>
<p><strong>Example</strong></p>
<pre><code>valo:hasExactValue rdf:type owl:DatatypeProperty ;
    rdfs:label &quot;has exact value&quot; ;
    rdfs:subPropertyOf sio:hasValue .

val-kb:AgeOfSamantha valo:hasExactValue &quot;25.82&quot;^^xsd:decimal .
</code></pre><p>A reasoner should infer <code>val-kb:AgeOfSamantha sio:hasValue 25.82 .</code></p>
<h4 id="object-property-chain-inclusion">Object Property Chain Inclusion</h4>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?objectProperty ?o .
}
WHERE {
?objectProperty rdf:type owl:ObjectProperty ;
    owl:propertyChainAxiom ?list .
  ?list rdf:first ?prop1 .
  ?list rdf:rest/rdf:first ?prop2 .
  ?resource ?prop1 [ ?prop2 ?o ] .
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:isRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:label &quot;is related to&quot; ;
    dct:description &quot;A is related to B iff there is some relation between A and B.&quot; .

sio:isSpatiotemporallyRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:subPropertyOf sio:isRelatedTo ;
    rdfs:label &quot;is spatiotemporally related to&quot; ;
    dct:description &quot;A is spatiotemporally related to B iff A is in the spatial or temporal vicinity of B&quot; .

sio:overlapsWith rdf:type owl:ObjectProperty ,
        owl:SymmetricProperty ,
        owl:ReflexiveProperty ;
    rdfs:subPropertyOf sio:isSpatiotemporallyRelatedTo ;
    owl:propertyChainAxiom ( sio:overlapsWith sio:isPartOf ) ;
    dct:description &quot;A overlaps with B iff there is some C that is part of both A and B.&quot; ;
    rdfs:label &quot;overlaps with&quot; .

val-kb:Rug rdf:type sio:Object ;
    rdfs:label &quot;rug&quot; ;
    sio:overlapsWith ex-kb:FloorPanel .

val-kb:FloorPanel rdf:type sio:Object ;
    rdfs:label &quot;floor panel&quot; ;
    sio:isPartOf ex-kb:Floor .

val-kb:Floor rdf:type sio:Object ;
    rdfs:label &quot;floor&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Rug sio:overlapsWith val-kb:Floor .</code></p>
<h3 id="equivalence">Equivalence</h3>
<h4 id="class-equivalence">Class Equivalence</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C_1\equiv%20C_2" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?equivClass .
}
WHERE {
  ?resource rdf:type ?superClass.
  {?superClass owl:equivalentClass ?equivClass .}
    UNION
  {?equivClass owl:equivalentClass ?superClass .}
}

</code></pre><p><strong>Explanation</strong></p>
<p><em>superClass</em> is equivalent to <em>equivClass</em>, so since <em>resource</em> is a <em>superClass</em>, it is also a <em>equivClass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Fake rdf:type owl:Class ;
    owl:equivalentClass sio:Fictional ;
    rdfs:label &quot;fake&quot; .

val-kb:Hubert rdf:type valo:Fake ;
    rdfs:label &quot;Hubert&quot; .
</code></pre><p>A reasoner should infer <code>{val-kb:Hubert rdf:type sio:Fictional .</code></p>
<h4 id="property-equivalence">Property Equivalence</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=P_1\equiv%20P_2" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?equivProperty ?o .
}
WHERE {
  ?resource ?p ?o .
  {?p owl:equivalentProperty ?equivProperty .}
    UNION
  {?equivProperty owl:equivalentProperty ?p . }
}
</code></pre><p><strong>Explanation</strong></p>
<p>The properties _p_ and <em>equivProperty</em> are equivalent. Therefore, since <em>resource</em> _p_ _o_, it is implied that <em>resource</em> <em>equivProperty</em> _o_.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

val-kb:AgeOfSamantha rdf:type sio:Age ;
    rdfs:label &quot;Samantha&#39;s age&quot; ;
    sio:hasValue &quot;25.82&quot;^^xsd:decimal .

valo:hasValue rdf:type owl:DatatypeProperty ;
    rdfs:label &quot;has value&quot; ;
    owl:equivalentProperty sio:hasValue .
</code></pre><p>A reasoner should infer <code>val-kb:AgeOfSamantha valo:hasValue 25.82 .</code></p>
<h3 id="disjointness">Disjointness</h3>
<h4 id="class-disjointness">Class Disjointness</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C_1\neq%20C_2" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class .
  ?resource rdf:type ?disjointClass .
  { ?class owl:disjointWith ?disjointClass . } 
    UNION
  { ?disjointClass owl:disjointWith ?class . }
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is a disjoint with <em>disjointClass</em>, any resource that is an instance of <em>class</em> is not an instance of <em>disjointClass</em>. Therefore, since <em>resource</em> is an instance of <em>class</em>, it can not be an instance of <em>disjointClass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Entity rdf:type owl:Class ;
    rdfs:label &quot;entity&quot; ;
    dct:description &quot;Every thing is an entity.&quot; .

sio:Attribute rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;attribute&quot; ;
    dct:description &quot;An attribute is a characteristic of some entity.&quot; .

sio:RealizableEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Attribute ;
    dct:description &quot;A realizable entity is an attribute that is exhibited under some condition and is realized in some process.&quot; ;
    rdfs:label &quot;realizable entity&quot; .

sio:Quality rdf:type owl:Class ;
    rdfs:subClassOf sio:Attribute ;
    owl:disjointWith sio:RealizableEntity ;
    dct:description &quot;A quality is an attribute that is intrinsically associated with its bearer (or its parts), but whose presence/absence and observed/measured value may vary.&quot; ;
    rdfs:label &quot;quality&quot; .

sio:ExistenceQuality rdf:type owl:Class ;
    rdfs:subClassOf sio:Quality ;
    dct:description &quot;existence quality is the quality of an entity that describe in what environment it is known to exist.&quot; ;
    rdfs:label &quot;existence quality&quot; .

sio:Virtual rdf:type owl:Class ;
    rdfs:subClassOf sio:ExistenceQuality ;
    dct:description &quot;virtual is the quality of an entity that exists only in a virtual setting such as a simulation or game environment.&quot; ;
    rdfs:label &quot;virtual&quot; .

sio:Real rdf:type owl:Class ;
    rdfs:subClassOf sio:ExistenceQuality ;
    owl:disjointWith sio:Fictional ;
    owl:disjointWith sio:Virtual ;
    dct:description &quot;real is the quality of an entity that exists in real space and time.&quot; ;
    rdfs:label &quot;real&quot; .

sio:Hypothetical rdf:type owl:Class ;
    rdfs:subClassOf sio:ExistenceQuality ;
    dct:description &quot;hypothetical is the quality of an entity that is conjectured to exist.&quot; ;
    rdfs:label &quot;hypothetical&quot; .

sio:Fictional rdf:type owl:Class ;
    rdfs:subClassOf sio:Hypothetical ;
    dct:description &quot;fictional is the quality of an entity that exists only in a creative work of fiction.&quot; ;
    rdfs:label &quot;fictional&quot; .

val-kb:ImaginaryFriend
    rdfs:label &quot;my imaginary friend&quot; ;
    rdf:type sio:Real ;
    rdf:type sio:Fictional .
</code></pre><p>A reasoner should infer <code>val-kb:ImaginaryFriend rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h4 id="property-disjointness">Property Disjointness</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?p1 ?o1 ,
      ?o2 .
  ?resource ?p2 ?o2.
  {?p1 owl:propertyDisjointWith ?p2 .}
    UNION
  {?p2 owl:propertyDisjointWith ?p1 .}
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since properties _p1_ and _p2_ are disjoint, <em>resource</em> having both _p2_ _o2_ as well as _p1_ _o2_ leads to an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>valo:hasMother rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf sio:hasAttribute ;
    rdfs:label &quot;has mother&quot; ;
    owl:propertyDisjointWith valo:hasFather .

valo:hasFather rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has father&quot; .

val-kb:Jordan rdf:type sio:Human ;
    rdfs:label &quot;Jordan&quot; .

val-kb:Susan rdf:type sio:Human ;
    rdfs:label &quot;Susan&quot; ;
    valo:hasFather val-kb:Jordan ;
    valo:hasMother val-kb:Jordan .
</code></pre><p>A reasoner should infer <code>val-kb:Susan rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h4 id="all-disjoint-classes">All Disjoint Classes</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member owl:disjointWith ?item .
}
WHERE {
  ?restriction rdf:type owl:AllDisjointClasses ;
    owl:members ?list .
  ?list rdf:rest*/rdf:first ?member .
  {
    SELECT DISTINCT ?item ?restrict WHERE
    {
      ?restrict rdf:type owl:AllDisjointClasses ;
        owl:members ?list .
      ?list rdf:rest*/rdf:first ?item .
    }
  }
  BIND(?restriction AS ?restrict)
  FILTER(?member != ?item)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>restriction</em> is an all disjoint classes restriction with classes listed in <em>list</em>, each member in <em>list</em> is disjoint with each other member in the list.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Entity rdf:type owl:Class ;
    rdfs:label &quot;entity&quot; ;
    dct:description &quot;Every thing is an entity.&quot; .

sio:Process rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    dct:description &quot;A process is an entity that is identifiable only through the unfolding of time, has temporal parts, and unless otherwise specified/predicted, cannot be identified from any instant of time in which it exists.&quot; ;
    rdfs:label &quot;process&quot; .

sio:Attribute rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;attribute&quot; ;
    dct:description &quot;An attribute is a characteristic of some entity.&quot; .

sio:Object rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;object&quot; ;
    dct:description &quot;An object is an entity that is wholly identifiable at any instant of time during which it exists.&quot; .

[ rdf:type owl:AllDisjointClasses ;
    owl:members ( sio:Process sio:Attribute sio:Object ) ] .
</code></pre><p>A reasoner should infer <code>sio:Process owl:disjointWith sio:Object , sio:Attribute . sio:Attribute owl:disjointWith sio:Object , sio:Process . sio:Object owl:disjointWith sio:Attribute, sio:Process .</code></p>
<h4 id="all-disjoint-properties">All Disjoint Properties</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member owl:propertyDisjointWith ?item .
}
WHERE {
  ?restriction rdf:type owl:AllDisjointProperties ;
    owl:members ?list .
  ?list rdf:rest*/rdf:first ?member .
  {
    SELECT DISTINCT ?item ?restrict WHERE
    {
      ?restrict rdf:type owl:AllDisjointProperties ;
        owl:members ?list .
      ?list rdf:rest*/rdf:first ?item .
    }
  }
  BIND(?restriction AS ?restrict)
  FILTER(?member != ?item)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>restriction</em> is an all disjoint properties restriction with properties listed in <em>list</em>, each member in <em>list</em> is disjoint with each other property in the list.</p>
<p><strong>Example</strong></p>
<pre><code>val-kb:DisjointPropertiesRestriction rdf:type owl:AllDisjointProperties ;
    owl:members ( valo:hasMother valo:hasFather valo:hasSibling ) .

valo:hasMother rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has mother&quot; .

valo:hasFather rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has father&quot; .

valo:hasSibling rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has sibling&quot; .
</code></pre><p>A reasoner should infer <code>valo:hasMother owl:propertyDisjointWith valo:hasFather , valo:hasSibling . valo:hasFather owl:propertyDisjointWith valo:hasMother , valo:hasSibling . valo:hasSibling owl:propertyDisjointWith valo:hasMother , valo:hasFather .</code></p>
<h3 id="transitivity">Transitivity</h3>
<h4 id="object-property-transitivity">Object Property Transitivity</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=P^+%20\sqsubseteq%20P" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?transitiveProperty ?o2 .
}
WHERE {
  ?resource ?transitiveProperty ?o1 .
  ?o1 ?transitiveProperty ?o2 .
  ?transitiveProperty rdf:type owl:TransitiveProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>transitiveProperty</em> is a transitive object property, and the relationships <em>resource</em> <em>transitiveProperty</em> _o1_ and _o1_ <em>transitiveProperty</em> _o2_ exist, then we can infer that <em>resource</em> <em>transitiveProperty</em> _o2_.</p>
<p><strong>Example</strong></p>
<pre><code>sio:isRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:label &quot;is related to&quot; ;
    dct:description &quot;A is related to B iff there is some relation between A and B.&quot; .

sio:isSpatiotemporallyRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:subPropertyOf sio:isRelatedTo ;
    rdfs:label &quot;is spatiotemporally related to&quot; ;
    dct:description &quot;A is spatiotemporally related to B iff A is in the spatial or temporal vicinity of B&quot; .

sio:isLocationOf rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ;
    rdfs:subPropertyOf sio:isSpatiotemporallyRelatedTo ;
    rdfs:label &quot;is location of&quot; ;
    dct:description &quot;A is location of B iff the spatial region occupied by A has the spatial region occupied by B as a part.&quot; .

sio:hasPart rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ,
                                owl:ReflexiveProperty ;
    rdfs:subPropertyOf sio:isLocationOf ;
    owl:inverseOf sio:isPartOf ;
    rdfs:label &quot;has part&quot; ;
    dct:description &quot;has part is a transitive, reflexive and antisymmetric relation between a whole and itself or a whole and its part&quot; .

sio:isLocatedIn rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ;
    rdfs:subPropertyOf sio:isSpatiotemporallyRelatedTo ;
    rdfs:label &quot;is located in&quot; ;
    dct:description &quot;A is located in B iff the spatial region occupied by A is part of the spatial region occupied by B.&quot; .

sio:isPartOf rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ,
                                owl:ReflexiveProperty ;
    rdfs:subPropertyOf sio:isLocatedIn ;
    rdfs:label &quot;is part of&quot; ;
    dct:description &quot;is part of is a transitive, reflexive and anti-symmetric mereological relation between a whole and itself or a part and its whole.&quot; .

val-kb:Fingernail rdf:type owl:Individual ;
    rdfs:label &quot;finger nail&quot; ;
    sio:isPartOf val-kb:Finger .

val-kb:Finger rdf:type owl:Individual ;
    rdfs:label &quot;finger&quot; ;
    sio:isPartOf val-kb:Hand . 

val-kb:Hand rdf:type owl:Individual ;
    rdfs:label &quot;hand&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Fingernail sio:isPartOf val-kb:Hand .</code></p>
<h3 id="reflexivity">Reflexivity</h3>
<h4 id="object-property-reflexivity">Object Property Reflexivity</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?reflexiveProperty ?resource .
}
WHERE {
  ?resource rdf:type ?type ;
    ?reflexiveProperty ?o .
  ?o rdf:type ?type.
  ?reflexiveProperty rdf:type owl:ReflexiveProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> has a <em>reflexiveProperty</em> assertion to _o_, <em>resource</em> and _o_ are both of type <em>type</em>, and <em>reflexiveProperty</em> is a reflexive property, we can infer that <em>resource</em> <em>reflexiveProperty</em> <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Process rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    dct:description &quot;A process is an entity that is identifiable only through the unfolding of time, has temporal parts, and unless otherwise specified/predicted, cannot be identified from any instant of time in which it exists.&quot; ;
    rdfs:label &quot;process&quot; .

val-kb:Workflow rdf:type sio:Process ;
    rdfs:label &quot;workflow&quot; ;
    sio:hasPart val-kb:Step .

val-kb:Step rdf:type sio:Process ;
    rdfs:label &quot;step&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Workflow sio:hasPart val-kb:Workflow .</code></p>
<h4 id="object-property-irreflexivity">Object Property Irreflexivity</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?irreflexiveProperty ?o .
  ?irreflexiveProperty rdf:type owl:IrreflexiveProperty .
  ?resource ?irreflexiveProperty ?resource .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> has a <em>irreflexiveProperty</em> assertion, and <em>irreflexiveProperty</em> is a irreflexive property, we can infer that the relationship <em>resource</em> <em>irreflexiveProperty</em> <em>resource</em> does not exist.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasMember rdf:type owl:ObjectProperty ,
                                owl:IrreflexiveProperty ;
    rdfs:subPropertyOf sio:hasAttribute ;
    owl:inverseOf sio:isMemberOf ;
    rdfs:label &quot;has member&quot; ;
    dct:description &quot;has member is a mereological relation between a collection and an item.&quot; .

sio:isMemberOf rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf sio:isAttributeOf ;
    rdfs:label &quot;is member of&quot; ;
    dct:description &quot;is member of is a mereological relation between a item and a collection.&quot; .

sio:Collection rdf:type owl:Class ;
    rdfs:subClassOf sio:Set ;
    rdfs:label &quot;collection&quot; ;
    dct:description &quot;A collection is a set for which there exists at least one member, although any member need not to exist at any point in the collection&#39;s existence.&quot; .

sio:Set rdf:type owl:Class ;
    rdfs:subClassOf sio:MathematicalEntity ;
    rdfs:label &quot;set&quot; ;
    dct:description &quot;A set is a collection of entities, for which there may be zero members.&quot; .

sio:MathematicalEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    rdfs:label &quot;mathematical entity&quot; ;
    dct:description &quot;A mathematical entity is an information content entity that are components of a mathematical system or can be defined in mathematical terms.&quot; .

sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

val-kb:Group rdf:type sio:Collection ;
    rdfs:label &quot;group&quot; ;
    sio:hasMember val-kb:Group .
</code></pre><p>A reasoner should infer <code>val-kb:Group rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h3 id="symmetry">Symmetry</h3>
<h4 id="object-property-symmetry">Object Property Symmetry</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?o ?symmetricProperty ?resource .
}
WHERE {
  ?resource ?symmetricProperty ?o .
  ?symmetricProperty rdf:type owl:SymmetricProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>symmetricProperty</em> is a symmetric property, and <em>resource</em> <em>symmetricProperty</em> _o_, we can infer that _o_ <em>symmetricProperty</em> <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:isRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:label &quot;is related to&quot; ;
    dct:description &quot;A is related to B iff there is some relation between A and B.&quot; .

val-kb:Peter rdf:type sio:Human ;
    rdfs:label &quot;Peter&quot; ;
    sio:isRelatedTo val-kb:Samantha .

val-kb:Samantha rdf:type sio:Human ;
    rdfs:label &quot;Samantha&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Samantha sio:isRelatedTo val-kb:Peter .</code></p>
<h4 id="object-property-asymmetry">Object Property Asymmetry</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?asymmetricProperty ?o .
  ?asymmetricProperty rdf:type owl:AsymmetricProperty .
  ?o ?asymmetricProperty ?resource .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>asymmetricProperty</em> is an asymmetric property, and <em>resource</em> <em>asymmetricProperty</em> _o_, then the assertion _o_ <em>asymmetricProperty</em> <em>resource</em> results in an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>sio:isProperPartOf rdf:type owl:ObjectProperty ,
                                owl:AsymmetricProperty ,
                                owl:IrreflexiveProperty ;
    rdfs:label &quot;is proper part of&quot; ;
    rdfs:subPropertyOf sio:isPartOf ;
    dct:description &quot;is proper part of is an asymmetric, irreflexive (normally transitive) relation between a part and its distinct whole.&quot; .

val-kb:Nose rdf:type owl:Individual ;
    rdfs:label &quot;nose&quot; ;
    sio:isProperPartOf val-kb:Face .

val-kb:Face rdf:type owl:Individual ;
    sio:isProperPartOf val-kb:Nose ;
    rdfs:label &quot;face&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Face rdf:type owl:Nothing .</code> , <code>val-kb:Nose rdf:type owl:Nothing .</code> , and/or that an inconsistency occurs.</p>
<h3 id="functionality">Functionality</h3>
<h4 id="functional-object-property">Functional Object Property</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?functionalProperty ?o1 ,
      ?o2 .
  ?functionalProperty rdf:type owl:ObjectProperty , 
      owl:FunctionalProperty .
  FILTER (str(?o1) !=  str(?o2))
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>functionalProperty</em> is a functional object property, <em>resource</em> can only have one value for <em>functionalProperty</em>. Since <em>resource</em> <em>functionalProperty</em> both _o1_ and _o2_, we can infer that _o1_ and _o2_ must be the same individual.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Role rdf:type owl:Class ;
    rdfs:label &quot;role&quot; ;
    rdfs:subClassOf sio:RealizableEntity ;
    dct:description &quot;A role is a realizable entity that describes behaviours, rights and obligations of an entity in some particular circumstance.&quot; .

sio:isAttributeOf rdf:type owl:ObjectProperty ;
    rdfs:label &quot;is attribute of&quot; ;
    dct:description &quot;is attribute of is a relation that associates an attribute with an entity where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:hasAttribute rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has attribute&quot; ;
    dct:description &quot;has attribute is a relation that associates a entity with an attribute where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:isPropertyOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is property of&quot; ;
    dct:description &quot;is property of is a relation betweena  quality, capability or role and the entity that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:isAttributeOf .

sio:hasProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has property&quot; ;
    owl:inverseOf sio:isPropertyOf ;
    dct:description &quot;has property is a relation between an entity and the quality, capability or role that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:hasAttribute .

sio:hasRealizableProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has realizable property&quot; ;
    rdfs:subPropertyOf sio:hasProperty .

sio:isRealizablePropertyOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is realizable property of&quot; ;
    rdfs:subPropertyOf sio:isPropertyOf ;
    owl:inverseOf sio:hasRealizableProperty .

sio:isRoleOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is role of&quot; ;
    rdfs:domain sio:Role ;
    rdfs:subPropertyOf sio:isRealizablePropertyOf ;
    dct:description &quot;is role of is a relation between a role and the entity that it is a property of.&quot; ;
    owl:inverseOf sio:hasRole .

val-kb:Tutor rdf:type sio:Human ;
    rdfs:label &quot;tutor&quot; .

val-kb:TeachingRole rdf:type sio:Role ;
    rdfs:label &quot;teaching role&quot; ;
    sio:isRoleOf val-kb:Tutor .

val-kb:TutoringRole rdf:type sio:Role ;
    rdfs:label &quot;tutoring role&quot; ;
    sio:isRoleOf val-kb:Tutor .
</code></pre><p>A reasoner should infer <code>val-kb:TeachingRole owl:sameAs val-kb:TutoringRole .</code></p>
<h4 id="functional-data-property">Functional Data Property</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?functionalProperty ?o1 , 
      ?o2 .
  ?functionalProperty rdf:type owl:DatatypeProperty , 
      owl:FunctionalProperty .
  FILTER (str(?o1) !=  str(?o2))
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>functionalProperty</em> is a functional data property, <em>resource</em> can only have one value for <em>functionalProperty</em>. Since <em>resource</em> <em>functionalProperty</em> both _o1_ and _o2_, and _o1_ is different from _o2_, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

val-kb:HeightOfTom sio:hasValue &quot;5&quot;^^xsd:integer .
val-kb:HeightOfTom sio:hasValue &quot;6&quot;^^xsd:integer .
</code></pre><p>A reasoner should infer <code>val-kb:HeightOfTom rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h3 id="inversion">Inversion</h3>
<h4 id="object-property-inversion">Object Property Inversion</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?o ?inverseProperty ?resource .
}
WHERE {
  ?resource ?p ?o .
  ?p rdf:type owl:ObjectProperty .
  {?p owl:inverseOf ?inverseProperty .}
    UNION
  {?inverseProperty owl:inverseOf ?p . }
}
</code></pre><p><strong>Explanation</strong></p>
<p>The object properties _p_ and <em>inverseProperty</em> are inversely related to eachother. Therefore, since <em>resource</em> _p_ _o_, it is implied that _o_ <em>inverseProperty</em> <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasAttribute rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has attribute&quot; ;
    dct:description &quot;has attribute is a relation that associates a entity with an attribute where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:hasProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has property&quot; ;
    owl:inverseOf sio:isPropertyOf ;
    dct:description &quot;has property is a relation between an entity and the quality, capability or role that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:hasAttribute .

sio:Symbol rdf:type owl:Class ;
    rdfs:subClassOf sio:Representation ;
    dct:description &quot;A symbol is a proposition about what an entity represents.&quot; ;
    rdfs:label &quot;symbol&quot; .

sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

sio:Representation rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    dct:description &quot;A representation is a entity that in some way represents another entity (or attribute thereof).&quot; ;
    rdfs:label &quot;representation&quot; .

valo:MolecularFormula rdfs:subClassOf sio:Symbol ;
    rdfs:label &quot;molecular formula&quot; .

val-kb:Water sio:hasAttribute val-kb:H2O ;
    rdfs:label &quot;water&quot; .

val-kb:HyrdogenDioxide sio:hasAttribute val-kb:H2O ;
    rdfs:label &quot;hydrogen dioxide&quot; .

val-kb:H2O rdf:type valo:MolecularFormula ;
    rdfs:label &quot;H2O&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Water owl:sameAs val-kb:HyrdogenDioxide .</code></p>
<h5 id="inverse-functional-object-property">Inverse Functional Object Property</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource owl:sameAs ?individual .
}
WHERE {
  ?resource ?invFunctionalProperty ?o .
  ?individual ?invFunctionalProperty ?o .
  ?invFunctionalProperty rdf:type owl:ObjectProperty ,
      owl:InverseFunctionalProperty .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>invFunctionalProperty</em> is an inverse functional property, and <em>resource</em> and <em>individual</em> both have the relationship <em>invFunctionalProperty</em> _o_, then we can infer that <em>resource</em> is the same as <em>individual</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasAttribute rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has attribute&quot; ;
    dct:description &quot;has attribute is a relation that associates a entity with an attribute where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:hasProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has property&quot; ;
    owl:inverseOf sio:isPropertyOf ;
    dct:description &quot;has property is a relation between an entity and the quality, capability or role that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:hasAttribute .

sio:Entity rdf:type owl:Class ;
    rdfs:label &quot;entity&quot; ;
    dct:description &quot;Every thing is an entity.&quot; .

sio:Object rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;object&quot; ;
    dct:description &quot;An object is an entity that is wholly identifiable at any instant of time during which it exists.&quot; .

sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

sio:Representation rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    dct:description &quot;A representation is a entity that in some way represents another entity (or attribute thereof).&quot; ;
    rdfs:label &quot;representation&quot; .

sio:Symbol rdf:type owl:Class ;
    rdfs:subClassOf sio:Representation ;
    dct:description &quot;A symbol is a proposition about what an entity represents.&quot; ;
    rdfs:label &quot;symbol&quot; .

valo:MolecularFormula rdfs:subClassOf sio:Symbol ;
    rdfs:label &quot;molecular formula&quot; .

val-kb:Water sio:hasProperty ex-kb:H2O ;
    rdfs:label &quot;water&quot; .

val-kb:HyrdogenDioxide sio:hasProperty ex-kb:H2O ;
    rdfs:label &quot;hydrogen dioxide&quot; .

val-kb:H2O rdf:type ex:MolecularFormula ;
    rdfs:label &quot;H2O&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Water owl:sameAs val-kb:HyrdogenDioxide .</code></p>
<h3 id="domain-range-restrictions">Domain &amp; Range Restrictions</h3>
<h4 id="domain-restriction">Domain Restriction</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?class .
}
WHERE {
  ?resource ?p ?o .
  ?p rdfs:domain ?class .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since the domain of _p_ is <em>class</em>, this implies that <em>resource</em> is a <em>class</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Role rdf:type owl:Class ;
    rdfs:label &quot;role&quot; ;
    rdfs:subClassOf sio:RealizableEntity ;
    dct:description &quot;A role is a realizable entity that describes behaviours, rights and obligations of an entity in some particular circumstance.&quot; .

sio:isAttributeOf rdf:type owl:ObjectProperty ;
    rdfs:label &quot;is attribute of&quot; ;
    dct:description &quot;is attribute of is a relation that associates an attribute with an entity where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:hasAttribute rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has attribute&quot; ;
    dct:description &quot;has attribute is a relation that associates a entity with an attribute where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:isPropertyOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is property of&quot; ;
    dct:description &quot;is property of is a relation betweena  quality, capability or role and the entity that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:isAttributeOf .

sio:hasProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has property&quot; ;
    owl:inverseOf sio:isPropertyOf ;
    dct:description &quot;has property is a relation between an entity and the quality, capability or role that it and it alone bears.&quot; ;
    rdfs:subPropertyOf sio:hasAttribute .

sio:hasRealizableProperty rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has realizable property&quot; ;
    rdfs:subPropertyOf sio:hasProperty .

sio:isRealizablePropertyOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is realizable property of&quot; ;
    rdfs:subPropertyOf sio:isPropertyOf ;
    owl:inverseOf sio:hasRealizableProperty .

sio:isRoleOf rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;is role of&quot; ;
    rdfs:domain sio:Role ;
    rdfs:subPropertyOf sio:isRealizablePropertyOf ;
    dct:description &quot;is role of is a relation between a role and the entity that it is a property of.&quot; ;
    owl:inverseOf sio:hasRole .

sio:hasRole rdf:type owl:ObjectProperty ,
                                owl:InverseFunctionalProperty;
    rdfs:label &quot;has role&quot; ;
    rdfs:subPropertyOf sio:hasRealizableProperty ;
    dct:description &quot;has role is a relation between an entity and a role that it bears.&quot; .

sio:Human  rdf:type owl:Class ;
    rdfs:label &quot;human&quot; ;
    rdfs:subClassOf sio:MulticellularOrganism ;
    dct:description &quot;A human is a primates of the family Hominidae and are characterized by having a large brain relative to body size, with a well developed neocortex, prefrontal cortex and temporal lobes, making them capable of abstract reasoning, language, introspection, problem solving and culture through social learning.&quot; .

sio:MulticellularOrganism  rdf:type owl:Class ;
    rdfs:label &quot;multicellular organism&quot; ;
    rdfs:subClassOf sio:CellularOrganism ;
    dct:description &quot;A multi-cellular organism is an organism that consists of more than one cell.&quot; .

sio:CellularOrganism  rdf:type owl:Class ;
    rdfs:label &quot;cellular organism&quot; ;
    rdfs:subClassOf sio:Organism ;
    dct:description &quot;A cellular organism is an organism that contains one or more cells.&quot; .

sio:Non-cellularOrganism  rdf:type owl:Class ;
    rdfs:label &quot;non-cellular organism&quot; ;
    rdfs:subClassOf sio:Organism ;
    dct:description &quot;A non-cellular organism is an organism that does not contain a cell.&quot; .

sio:Organism rdf:type owl:Class ;
    owl:equivalentClass 
        [   rdf:type owl:Class ;
            owl:unionOf ( sio:CellularOrganism sio:Non-cellularOrganism ) ] ;
    rdfs:subClassOf sio:BiologicalEntity ;
    dct:description &quot;A biological organisn is a biological entity that consists of one or more cells and is capable of genomic replication (independently or not).&quot; ;
    rdfs:label &quot;organism&quot; .

sio:BiologicalEntity  rdf:type owl:Class ;
    rdfs:label &quot;biological entity&quot; ;
    rdfs:subClassOf sio:HeterogeneousSubstance ;
    dct:description &quot;A biological entity is a heterogeneous substance that contains genomic material or is the product of a biological process.&quot; .

sio:HeterogeneousSubstance  rdf:type owl:Class ;
    rdfs:label &quot;heterogeneous substance&quot; ;
    rdfs:subClassOf sio:MaterialEntity ;
    rdfs:subClassOf sio:ChemicalEntity ;
    dct:description &quot;A heterogeneous substance is a chemical substance that is composed of more than one different kind of component.&quot; .

sio:MaterialEntity  rdf:type owl:Class ;
    rdfs:label &quot;material entity&quot; ;
    rdfs:subClassOf sio:Object ;
    dct:description &quot;A material entity is a physical entity that is spatially extended, exists as a whole at any point in time and has mass.&quot; .

sio:ChemicalEntity  rdf:type owl:Class ;
    rdfs:label &quot;chemical entity&quot; ;
    rdfs:subClassOf sio:MaterialEntity ;
    dct:description &quot;A chemical entity is a material entity that pertains to chemistry.&quot; .

val-kb:Mother rdf:type owl:Individual ;
    rdfs:label &quot;mother&quot; ;
    sio:isRoleOf val-kb:Sarah ;
    sio:inRelationTo val-kb:Tim .

val-kb:Sarah rdf:type sio:Human ;
    rdfs:label &quot;Sarah&quot; .

val-kb:Tim rdf:type sio:Human ;
    rdfs:label &quot;Tim&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Mother rdf:type sio:Role .</code> and/or <code>val-kb:Sarah sio:hasRole val-kb:Mother .</code></p>
<h4 id="range-restriction">Range Restriction</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?o rdf:type ?class .
}
WHERE {
  ?resource ?p ?o .
  ?p rdfs:range ?class .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since the range of _p_ is <em>class</em>, this implies that _o_ is a <em>class</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:UnitOfMeasurement rdf:type owl:Class ;
    rdfs:label &quot;unit of measurement&quot; ;
    rdfs:subClassOf sio:Quantity ;
    dct:description &quot;A unit of measurement is a definite magnitude of a physical quantity, defined and adopted by convention and/or by law, that is used as a standard for measurement of the same physical quantity.&quot; .

sio:hasUnit rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has unit&quot; ;
    owl:inverseOf sio:isUnitOf ;
    rdfs:range sio:UnitOfMeasurement ;
    rdfs:subPropertyOf sio:hasAttribute ;
    dct:description &quot;has unit is a relation between a quantity and the unit it is a multiple of.&quot; .

sio:isUnitOf rdf:type owl:ObjectProperty ;
    rdfs:label &quot;is unit of&quot; ;
    rdfs:domain sio:UnitOfMeasurement ;
    rdfs:subPropertyOf sio:isAttributeOf ;
    dct:description &quot;is unit of is a relation between a unit and a quantity that it is a multiple of.&quot; .

sio:Height rdf:type owl:Class ;
    rdfs:label &quot;height&quot; ;
    rdfs:subClassOf sio:1DExtentQuantity ;
    dct:description &quot;Height is the one dimensional extent along the vertical projection of a 3D object from a base plane of reference.&quot; .

sio:1DExtentQuantity rdf:type owl:Class ;
    rdfs:label &quot;1D extent quantity&quot; ;
    rdfs:subClassOf sio:SpatialQuantity ;
    dct:description &quot;A quantity that extends in single dimension.&quot; .

sio:SpatialQuantity rdf:type owl:Class ;
    rdfs:label &quot;spatial quantity&quot; ;
    rdfs:subClassOf sio:DimensionalQuantity ;
    dct:description &quot;A spatial quantity is a quantity obtained from measuring the spatial extent of an entity.&quot; .

sio:DimensionalQuantity rdf:type owl:Class ;
    rdfs:label &quot;dimensional quantity&quot; ;
    rdfs:subClassOf sio:Quantity ,
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasUnit ;
            owl:someValuesFrom sio:UnitOfMeasurement ] ;
    dct:description &quot;A dimensional quantity is a quantity that has an associated unit.&quot; .

val-kb:Tom rdf:type sio:Human ;
    rdfs:label &quot;Tom&quot; ;
    sio:hasAttribute val-kb:HeightOfTom .

val-kb:HeightOfTom rdf:type sio:Height ;
    sio:hasUnit val-kb:Meter .

val-kb:Meter rdf:type owl:Individual ;
    rdfs:label &quot;meter&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Meter rdf:type sio:UnitOfMeasurement .</code></p>
<h3 id="datatype">Datatype</h3>
<h4 id="datatype-restriction">Datatype Restriction</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ;
    ?dataProperty ?value .
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Restriction ;
        owl:onProperty ?dataProperty ; 
        owl:someValuesFrom ?datatype ] .
  ?dataProperty rdf:type owl:DatatypeProperty .
  ?datatype rdf:type rdfs:Datatype ;
    owl:onDatatype ?restrictedDatatype ;
    owl:withRestrictions ?list .
  {
    ?list rdf:first ?min .
    ?list rdf:rest/rdf:first ?max .
    ?min xsd:minInclusive ?minValue .
    ?max xsd:maxInclusive ?maxValue .
  }
  UNION
  {
    ?list rdf:first ?max .
    ?list rdf:rest/rdf:first ?min .
    ?min xsd:minInclusive ?minValue .
    ?max xsd:maxInclusive ?maxValue .
  }
  FILTER(?value &lt; ?minValue || ?value &gt; ?maxValue)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> has a with restriction on datatype property <em>dataProperty</em> to be within the range specified in <em>list</em> with min value <em>minValue</em> and max value <em>maxValue</em>, and <em>resource</em> is of type <em>class</em> and has a value <em>value</em> for <em>dataProperty</em> which is outside the specified range, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

sio:ProbabilityMeasure rdf:type owl:Class ;
    rdfs:subClassOf sio:DimensionlessQuantity ;
    dct:description &quot;A probability measure is quantity of how likely it is that some event will occur.&quot; ;
    rdfs:label &quot;probability measure&quot; .

sio:ProbabilityValue rdf:type owl:Class ;
    rdfs:subClassOf sio:ProbabilityMeasure ;
    rdfs:subClassOf
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasValue ;
            owl:someValuesFrom 
                [ rdf:type rdfs:Datatype ;
                    owl:onDatatype xsd:double ;
                    owl:withRestrictions ( [ xsd:minInclusive &quot;0.0&quot;^^xsd:double ] [ xsd:maxInclusive &quot;1.0&quot;^^xsd:double ] ) 
                ]
        ] ;
    dct:description &quot;A p-value or probability value is the probability of obtaining a test statistic at least as extreme as the one that was actually observed, assuming that the null hypothesis is true&quot; ;
    #&lt;sio:hasSynonym xml:lang=&quot;en&quot;&gt;p-value&lt;/sio:hasSynonym&gt;
    rdfs:label &quot;probability value&quot; .

val-kb:EffortExerted rdf:type sio:ProbabilityValue ;
    rdfs:label &quot;effort exerted&quot; ;
    sio:hasValue &quot;1.1&quot;^^xsd:double .
</code></pre><p>A reasoner should infer <code>val-kb:EffortExerted rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h3 id="assertions">Assertions</h3>
<h4 id="same-individual">Same Individual</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?individual ?p ?o .
}
WHERE {
  ?resource owl:sameAs ?individual .
  ?resource ?p ?o .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> is the same as <em>individual</em>, they share the same properties.</p>
<p><strong>Example</strong></p>
<pre><code>val-kb:Peter rdf:type sio:Human ;
    rdfs:label &quot;Peter&quot; ;
    sio:isRelatedTo val-kb:Samantha .

val-kb:Samantha rdf:type sio:Human ;
    rdfs:label &quot;Samantha&quot; .

val-kb:Peter owl:sameAs val-kb:Pete .
</code></pre><p>A reasoner should infer <code>val-kb:Pete rdf:type sio:Human ; rdfs:label &quot;Peter&quot; ; sio:isRelatedTo val-kb:Samantha .</code></p>
<h4 id="different-individuals">Different Individuals</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource owl:differentFrom ?individual ;
    owl:sameAs ?individual .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> is asserted as being different from <em>individual</em>, the assertion that <em>resource</em> is the same as <em>individual</em> leads to an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>val-kb:Sam owl:differentFrom val-kb:Samantha .
val-kb:Sam owl:sameAs val-kb:Samantha .
</code></pre><p>A reasoner should infer <code>val-kb:Sam rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h4 id="all-different-individuals">All Different Individuals</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member owl:differentFrom ?item .
}
WHERE {
  ?restriction rdf:type owl:AllDifferent ;
    owl:distinctMembers ?list .
  ?list rdf:rest*/rdf:first ?member .
  {
    SELECT DISTINCT ?item ?restrict WHERE
    {
      ?restrict rdf:type owl:AllDifferent ;
        owl:distinctMembers ?list .
      ?list rdf:rest*/rdf:first ?item .
    }
  }
  BIND(?restriction AS ?restrict) 
  FILTER(?member != ?item)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>restriction</em> is an all different restriction with individuals listed in <em>list</em>, each member in <em>list</em> is different from each other member in the list.</p>
<p><strong>Example</strong></p>
<pre><code>val-kb:DistinctTypesRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        ( val-kb:Integer
        val-kb:String 
        val-kb:Boolean
        val-kb:Double 
        val-kb:Float 
        val-kb:Tuple 
        ) .
</code></pre><p>A reasoner should infer</p>
<pre><code>val-kb:Integer owl:differentFrom 
    val-kb:String , val-kb:Boolean, val-kb:Double , val-kb:Float , val-kb:Tuple .
val-kb:String owl:differentFrom 
    val-kb:Integer , val-kb:Boolean, val-kb:Double, val-kb:Float , val-kb:Tuple .
val-kb:Boolean owl:differentFrom 
    val-kb:Integer , val-kb:String, val-kb:Double, val-kb:Float , val-kb:Tuple .
val-kb:Double owl:differentFrom 
    val-kb:Integer , val-kb:String , val-kb:Boolean, val-kb:Float , val-kb:Tuple .
val-kb:Float owl:differentFrom 
    val-kb:Integer , val-kb:String , val-kb:Boolean, val-kb:Double , val-kb:Tuple .
val-kb:Tuple owl:differentFrom 
    val-kb:Integer , val-kb:String , val-kb:Boolean, val-kb:Double, val-kb:Float .
</code></pre><h4 id="class-assertion">Class Assertion</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?superClass .
}
WHERE {
  ?resource rdf:type ?class .
  ?class rdf:type owl:Class ;
    rdfs:subClassOf+ ?superClass .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is a subclass of <em>superClass</em>, any individual that is an instance of <em>class</em> is also an instance of <em>superClass</em>. Therefore, <em>resource</em> is an instance of <em>superClass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Entity rdf:type owl:Class ;
    rdfs:label &quot;entity&quot; ;
    dct:description &quot;Every thing is an entity.&quot; .

sio:Attribute rdf:type owl:Class ;
    rdfs:subClassOf sio:Entity ;
    rdfs:label &quot;attribute&quot; ;
    dct:description &quot;An attribute is a characteristic of some entity.&quot; .

sio:RealizableEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Attribute ;
    dct:description &quot;A realizable entity is an attribute that is exhibited under some condition and is realized in some process.&quot; ;
    rdfs:label &quot;realizable entity&quot; .

sio:Quality rdf:type owl:Class ;
    rdfs:subClassOf sio:Attribute ;
    owl:disjointWith sio:RealizableEntity ;
    dct:description &quot;A quality is an attribute that is intrinsically associated with its bearer (or its parts), but whose presence/absence and observed/measured value may vary.&quot; ;
    rdfs:label &quot;quality&quot; .

val-kb:Reliable rdf:type sio:Quality ;
    rdfs:label &quot;reliable&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Reliable rdf:type sio:Attribute , sio:Entity .</code></p>
<h4 id="property-assertion">Property Assertion</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><p>A reasoner should infer <code></code></p>
<h5 id="object-property-assertion">Object Property Assertion</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><p>A reasoner should infer <code></code></p>
<h5 id="data-property-assertion">Data Property Assertion</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><p>A reasoner should infer <code></code></p>
<h5 id="negative-object-property-assertion">Negative Object Property Assertion</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?p ?o.
  ?p rdf:type owl:ObjectProperty .
  ?x rdf:type owl:NegativePropertyAssertion ;
    owl:sourceIndividual ?resource ;
    owl:assertionProperty ?p ;
    owl:targetIndividual ?o .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since a negative object property assertion was made with source <em>resource</em>, object property _p_, and target individual _o_, the existence of <em>resource</em> _p_ _o_ results in an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasAttribute rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has attribute&quot; ;
    dct:description &quot;has attribute is a relation that associates a entity with an attribute where an attribute is an intrinsic characteristic such as a quality, capability, disposition, function, or is an externally derived attribute determined from some descriptor (e.g. a quantity, position, label/identifier) either directly or indirectly through generalization of entities of the same type.&quot; ;
    rdfs:subPropertyOf sio:isRelatedTo .

sio:hasUnit rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has unit&quot; ;
    owl:inverseOf sio:isUnitOf ;
    rdfs:range sio:UnitOfMeasurement ;
    rdfs:subPropertyOf sio:hasAttribute ;
    dct:description &quot;has unit is a relation between a quantity and the unit it is a multiple of.&quot; .

ex-kb:AgeOfSamantha rdf:type sio:Age ;
    rdfs:label &quot;Samantha&#39;s age&quot; .

ex-kb:NOPA rdf:type owl:NegativePropertyAssertion ; 
    owl:sourceIndividual ex-kb:AgeOfSamantha ; 
    owl:assertionProperty sio:hasUnit ; 
    owl:targetIndividual ex-kb:Meter .

ex-kb:AgeOfSamantha sio:hasUnit ex-kb:Meter .
</code></pre><p>A reasoner should infer <code>ex-kb:AgeOfSamantha rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h5 id="negative-data-property-assertion">Negative Data Property Assertion</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource ?p ?o.
  ?p rdf:type owl:DatatypeProperty .
  ?x rdf:type owl:NegativePropertyAssertion ;
    owl:sourceIndividual ?resource ;
    owl:assertionProperty ?p ;
    owl:targetValue ?o .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since a negative datatype property assertion was made with source <em>resource</em>, datatype property _p_, and target value _o_, the existence of <em>resource</em> _p_ _o_ results in an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>val-kb:NDPA rdf:type owl:NegativePropertyAssertion ; 
    owl:sourceIndividual val-kb:AgeOfPeter ; 
    owl:assertionProperty sio:hasValue ; 
    owl:targetValue &quot;10&quot; .

val-kb:AgeOfPeter rdf:type sio:Age;
    rdfs:label &quot;Peter&#39;s age&quot; ;
    sio:hasValue &quot;10&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:AgeOfPeter rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h3 id="keys">Keys</h3>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource owl:sameAs ?individual .
}
WHERE {
  ?resource rdf:type ?class ;
    ?keyProperty ?keyValue.
  ?class rdf:type owl:Class ;
    owl:hasKey ( ?keyProperty ) .
  ?individual rdf:type ?class ;
    ?keyProperty ?keyValue.
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> has key <em>keyProperty</em>, <em>resource</em> and <em>individual</em> are both of type <em>class</em>, and <em>resource</em> and <em>individual</em> both <em>keyProperty</em> <em>keyValue</em>, then <em>resource</em> and <em>individual</em> must be the same.</p>
<p><strong>Example</strong></p>
<pre><code>valo:uniqueID rdf:type owl:DatatypeProperty ;
    rdfs:label &quot;unique identifier&quot; .

valo:Person rdf:type owl:Class ;
    rdfs:subClassOf sio:Human ;
    rdfs:label &quot;person&quot; ;
    owl:hasKey ( valo:uniqueID ) .

val-kb:John rdf:type valo:Person ;
    rdfs:label &quot;John&quot; ;
    valo:uniqueID &quot;101D&quot; .

val-kb:Jack rdf:type valo:Person ;
    rdfs:label &quot;Jack&quot; ;
    valo:uniqueID &quot;101D&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:John owl:sameAs val-kb:Jack .</code></p>
<h3 id="existential-quantification">Existential Quantification</h3>
<h4 id="object-some-values-from">Object Some Values From</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\exists%20P.C" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?class .
}
WHERE {
  ?resource ?objectProperty
    [ rdf:type ?valueclass ] .
  ?objectProperty rdf:type owl:ObjectProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction;
      owl:onProperty ?objectProperty;
      owl:someValuesFrom ?valueclass ] .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> <em>objectProperty</em> an instance of <em>valueclass</em>, and <em>class</em> has a restriction on <em>objectProperty</em> to have some values from <em>valueclass</em>, we can infer that <em>resource</em> rdf:type <em>class</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:CollectionOf3dMolecularStructureModels rdf:type owl:Class ;
    rdfs:subClassOf sio:Collection ,
        [ rdf:type owl:Restriction ;
        owl:onProperty sio:hasMember ;
        owl:someValuesFrom sio:3dStructureModel ] ;
    rdfs:label &quot;collection of 3d molecular structure models&quot; ;
    dct:description &quot;A collection of 3D molecular structure models is just that.&quot; .

sio:3dStructureModel rdf:type owl:Class ;
    rdfs:subClassOf sio:TertiaryStructureDescriptor ;
    rdfs:label &quot;3d structure model&quot; ;
    dct:description &quot;A 3D structure model is a representation of the spatial arrangement of one or more chemical entities.&quot; .

sio:TertiaryStructureDescriptor rdf:type owl:Class ;
    rdfs:subClassOf sio:BiomolecularStructureDescriptor ;
    rdfs:label &quot;tertiary structure descriptor&quot; ;
    dct:description &quot;A tertiary structure descriptor describes 3D topological patterns in a biopolymer.&quot; .

sio:BiomolecularStructureDescriptor rdf:type owl:Class ;
    rdfs:subClassOf sio:MolecularStructureDescriptor ;
    rdfs:label &quot;biomolecular structure descriptor&quot; ;
    dct:description &quot;A biomolecular structure descriptor is structure description for organic compounds.&quot; .

sio:MolecularStructureDescriptor rdf:type owl:Class ;
    rdfs:subClassOf sio:ChemicalQuality ;
    rdfs:label &quot;molecular structure descriptor&quot; ;
    dct:description &quot;A molecular structure descriptor is data that describes some aspect of the molecular structure (composition) and is about some chemical entity.&quot; .

sio:ChemicalQuality rdf:type owl:Class ;
    rdfs:subClassOf sio:ObjectQuality ;
    rdfs:label &quot;chemical quality&quot; ;
    dct:description &quot;Chemical quality is the quality of a chemical entity.&quot; .

sio:ObjectQuality rdf:type owl:Class ;
    rdfs:subClassOf sio:Quality ;
    rdfs:label &quot;object quality&quot; ;
    dct:description &quot;An object quality is quality of an object.&quot; .

val-kb:MolecularCollection rdf:type owl:Individual ;
    rdfs:label &quot;molecular collection&quot; ;
    sio:hasMember val-kb:WaterMolecule .

val-kb:WaterMolecule rdf:type sio:3dStructureModel  .
</code></pre><p>A reasoner should infer <code>val-kb:MolecularCollection rdf:type sio:CollectionOf3dMolecularStructureModels .</code></p>
<h4 id="data-some-values-from">Data Some Values From</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ;
    ?datatypeProperty ?val .
  ?datatypeProperty rdf:type owl:DatatypeProperty .
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Restriction ;
        owl:onProperty ?datatypeProperty ;
        owl:someValuesFrom ?value ] .
  FILTER(DATATYPE(?val) != ?value)
}
</code></pre><p><strong>Explanation</strong></p>
<p><em>resource</em> <em>datatypeProperty</em> <em>val</em>, but <em>val</em> does not have the same datatype <em>value</em> restricted for <em>datatypeProperty</em> in <em>class</em>. Since <em>resource</em> rdf:type <em>class</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Text rdf:type owl:Class ;
    rdfs:subClassOf
        [ rdf:type owl:Restriction ;
        owl:onProperty sio:hasValue  ;
        owl:someValuesFrom xsd:string ] .

val-kb:Question rdf:type valo:Text ;
    sio:hasValue &quot;4&quot;^^xsd:integer .
</code></pre><p>A reasoner should infer <code>val-kb:Question rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h4 id="object-has-value">Object Has Value</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?objectProperty ?object .
}
WHERE {
  ?resource rdf:type ?class .
  ?objectProperty rdf:type owl:ObjectProperty.
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?objectProperty ;
      owl:hasValue ?object ] .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> is of type <em>class</em>, which has a value restriction on <em>objectProperty</em> to have <em>object</em>, we can infer that <em>resource</em> <em>objectProperty</em> <em>object</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:isRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:label &quot;is related to&quot; ;
    dct:description &quot;A is related to B iff there is some relation between A and B.&quot; .

sio:isSpatiotemporallyRelatedTo rdf:type owl:ObjectProperty ,
                                owl:SymmetricProperty ;
    rdfs:subPropertyOf sio:isRelatedTo ;
    rdfs:label &quot;is spatiotemporally related to&quot; ;
    dct:description &quot;A is spatiotemporally related to B iff A is in the spatial or temporal vicinity of B&quot; .

sio:isLocationOf rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ;
    rdfs:subPropertyOf sio:isSpatiotemporallyRelatedTo ;
    rdfs:label &quot;is location of&quot; ;
    dct:description &quot;A is location of B iff the spatial region occupied by A has the spatial region occupied by B as a part.&quot; .

sio:hasPart rdf:type owl:ObjectProperty ,
                                owl:TransitiveProperty ,
                                owl:ReflexiveProperty ;
    rdfs:subPropertyOf sio:isLocationOf ;
    owl:inverseOf sio:isPartOf ;
    rdfs:label &quot;has part&quot; ;
    dct:description &quot;has part is a transitive, reflexive and antisymmetric relation between a whole and itself or a whole and its part&quot; .

valo:Vehicle rdf:type owl:Class ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasPart ;
            owl:hasValue val-kb:Wheel ] .

val-kb:Car rdf:type ex:Vehicle ;
    sio:hasPart ex-kb:Mirror .

val-kb:Mirror owl:differentFrom ex-kb:Wheel .
</code></pre><p>A reasoner should infer <code>val-kb:Car sio:hasPart val-kb:Wheel .</code></p>
<h4 id="data-has-value">Data Has Value</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?class .
}
WHERE {
  ?resource ?datatypeProperty ?value.
  ?class owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?datatypeProperty ;
      owl:hasValue ?value ].
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is equivalent to the restriction on <em>datatypeProperty</em> to have value <em>value</em> and <em>resource</em> <em>datatypeProperty</em> <em>value</em>, we can infer that <em>resource</em> <em>rdf:type</em> <em>class</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Unliked rdf:type owl:Class ;
    owl:equivalentClass#rdfs:subClassOf
        [ rdf:type owl:Restriction ;
            owl:onProperty valo:hasAge ;
            owl:hasValue &quot;23&quot;^^xsd:integer ] .

val-kb:Tom valo:hasAge &quot;23&quot;^^xsd:integer .
</code></pre><p>A reasoner should infer <code>val-kb:Tom rdf:type ex:Unliked .</code></p>
<h3 id="universal-quantification">Universal Quantification</h3>
<h4 id="object-all-values-from">Object All Values From</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\forall%20P.C" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?valueclass.
}
WHERE {
  ?individual rdf:type ?class ; 
    ?objectProperty ?resource .
  ?objectProperty rdf:type owl:ObjectProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction;
      owl:onProperty ?objectProperty;
      owl:allValuesFrom ?valueclass ] .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> has a restriction on <em>objectProperty</em> to have all values from <em>valueclass</em>, <em>individual</em> <em>rdf:type</em> <em>class</em>, and <em>individual</em> <em>objectProperty</em> <em>resource</em>, we can infer that <em>resource</em> <em>rdf:type</em> <em>valueclass</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Namespace rdf:type owl:Class ;
    rdfs:subClassOf sio:ComputationalEntity ,
        [ rdf:type owl:Restriction ;
        owl:onProperty sio:hasMember ;
        owl:allValuesFrom sio:Identifier ] ;
    rdfs:label &quot;namespace&quot; ;
    dct:description &quot;A namespace is an informational entity that defines a logical container for a set of symbols or identifiers.&quot; .

sio:ComputationalEntity rdf:type owl:Class;
    rdfs:subClassOf sio:InformationContentEntity ;
    rdfs:label &quot;computational entity&quot; ;
    dct:description &quot;A computational entity is an information content entity operated on using some computational system.&quot; .

val-kb:NamespaceInstance rdf:type sio:Namespace ;
    sio:hasMember val-kb:NamespaceID .
</code></pre><p>A reasoner should infer \texttt{val-kb:NamespaceID rdf:type sio:Identifier .}</p>
<h4 id="data-all-values-from">Data All Values From</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ;
    ?datatypeProperty ?val .
  ?datatypeProperty rdf:type owl:DatatypeProperty .
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Restriction ;
        owl:onProperty ?datatypeProperty ;
        owl:allValuesFrom ?value ] .
  FILTER(DATATYPE(?val)!= ?value)
}
</code></pre><p><strong>Explanation</strong></p>
<p><em>resource</em> <em>datatypeProperty</em> <em>val</em>, but <em>val</em> does not have the same datatype <em>value</em> restricted for <em>datatypeProperty</em> in <em>class</em>. Since <em>resource</em> <em>rdf:type</em> <em>class</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Integer rdf:type owl:Class ;
    rdfs:subClassOf sio:ComputationalEntity ,
        [ rdf:type owl:Restriction ;
        owl:onProperty sio:hasValue ;
        owl:allValuesFrom xsd:integer ] ;
    rdfs:label &quot;integer&quot; .

val-kb:Ten rdf:type valo:Integer ;
    sio:hasValue &quot;10.1&quot;^^xsd:float .
</code></pre><p>A reasoner should infer <code>val-kb:Ten rdf:type owl:Nothing .</code> or than an inconsistency occurs.</p>
<h3 id="self-restriction">Self Restriction</h3>
<h4 id="object-has-self">Object Has Self</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?objectProperty ?resource .
}
WHERE {
  ?resource rdf:type ?class .
  ?objectProperty rdf:type owl:ObjectProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?objectProperty ;
      owl:hasSelf \&quot;true\&quot;^^xsd:boolean ] .
}
</code></pre><p><strong>Explanation</strong></p>
<p><em>resource</em> is of type <em>class</em>, which has a self restriction on the property <em>objectProperty</em>, allowing us to infer <em>resource</em> <em>objectProperty</em> <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:SelfAttributing rdf:type owl:Class ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasAttribute ;
            owl:hasSelf &quot;true&quot;^^xsd:boolean ] .

val-kb:Blue rdf:type valo:SelfAttributing .
</code></pre><p>A reasoner should infer <code>val-kb:Blue sio:hasAttribute val-kb:Blue .</code></p>
<h3 id="individual-enumeration">Individual Enumeration</h3>
<h4 id="object-one-of">Object One Of</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\{x_1\}\sqcup\dots\sqcup\{x_n\}" alt="formula"></p>
<h5 id="object-one-of-membership">Object One Of Membership</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member rdf:type ?resource .
}
WHERE {
  ?resource rdf:type owl:Class ;
    owl:oneOf ?list .
  ?list rdf:rest*/rdf:first ?member .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> has a one of relationship with <em>list</em>, the member <em>member</em> in <em>list</em> is of type <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Type rdf:type owl:Class ;
    owl:oneOf (val-kb:Integer val-kb:String val-kb:Boolean val-kb:Double val-kb:Float) .

val-kb:DistinctTypesRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        ( val-kb:Integer
        val-kb:String 
        val-kb:Boolean
        val-kb:Double 
        val-kb:Float 
        val-kb:Tuple 
        ) .
</code></pre><p>A reasoner should infer <code>val-kb:Integer rdf:type valo:Type . val-kb:String rdf:type valo:Type . val-kb:Boolean rdf:type valo:Type . val-kb:Double rdf:type valo:Type . val-kb:Float rdf:type valo:Type .</code></p>
<h5 id="object-one-of-inconsistency">Object One Of Inconsistency</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?class rdf:type owl:Class ;
    owl:oneOf ?list .
  ?list rdf:rest*/rdf:first ?member .
  ?resource rdf:type ?class .
  {
    SELECT DISTINCT (COUNT(DISTINCT ?concept) AS ?conceptCount)
    WHERE 
    {
      ?concept rdf:type owl:Class ;
        owl:oneOf ?list .
      ?individual rdf:type ?concept .
      ?list rdf:rest*/rdf:first ?member .
      FILTER(?individual = ?member)
    }
  }
  FILTER(?conceptCount=0)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> has a one of relationship with <em>list</em>, and <em>resource</em> is not in <em>list</em>, the assertion <em>resource</em> is a <em>class</em> leads to an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>valo:Type rdf:type owl:Class ;
    owl:oneOf (val-kb:Integer val-kb:String val-kb:Boolean val-kb:Double val-kb:Float) .

val-kb:DistinctTypesRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        ( val-kb:Integer
        val-kb:String 
        val-kb:Boolean
        val-kb:Double 
        val-kb:Float 
        val-kb:Tuple 
        ) .

val-kb:Tuple rdf:type valo:Type .
</code></pre><p>A reasoner should infer <code>val-kb:Tuple rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h4 id="data-one-of">Data One Of</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?datatypeProperty rdf:type owl:DatatypeProperty ;
    rdfs:range [ rdf:type owl:DataRange ;
      owl:oneOf ?list ] .
  ?resource ?datatypeProperty ?value .
  ?list rdf:rest*/rdf:first ?member .
  {
    SELECT DISTINCT (COUNT( DISTINCT ?datatypeProperty) AS ?dataCount)
    WHERE 
    {
      ?datatypeProperty rdf:type owl:DatatypeProperty ;
      rdfs:range [ rdf:type owl:DataRange ;
        owl:oneOf ?list ] .
      ?individual ?datatypeProperty ?value .
      ?list rdf:rest*/rdf:first ?member .
      FILTER(?value=?member)
    }
  }
  FILTER(?dataCount=0)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>datatypeProperty</em> is restricted to have a value from <em>list</em>, and <em>resource</em> <em>datatypeProperty</em> <em>value</em>, but <em>value</em> is not in <em>list</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>valo:hasTeenAge rdf:type owl:DatatypeProperty ;
    rdfs:label &quot;has age&quot; ;
    rdfs:range [ rdf:type owl:DataRange ;
        owl:oneOf (&quot;13&quot;^^xsd:integer &quot;14&quot;^^xsd:integer &quot;15&quot;^^xsd:integer &quot;16&quot;^^xsd:integer &quot;17&quot;^^xsd:integer &quot;18&quot;^^xsd:integer &quot;19&quot;^^xsd:integer )].

val-kb:Sarah valo:hasTeenAge &quot;12&quot;^^xsd:integer .
</code></pre><p>A reasoner should infer <code>val-kb:Sarah rdf:type owl:Nothing .</code> or that an inconsistency occurs.</p>
<h3 id="cardinality">Cardinality</h3>
<h4 id="max-cardinality">Max Cardinality</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\leq%20nP" alt="formula"></p>
<h5 id="object-max-cardinality">Object Max Cardinality</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ;
    ?objectProperty ?object .
  ?objectProperty rdf:type owl:ObjectProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?objectProperty ;
      owl:maxCardinality|owl:cardinality ?cardinalityValue ].
  FILTER(?objectCount &gt; ?cardinalityValue)
  {
    SELECT DISTINCT (COUNT(DISTINCT ?object) AS ?objectCount) ?individual ?concept
    WHERE 
    {
      ?individual rdf:type ?concept ;
        ?objectProperty ?object .
      ?objectProperty rdf:type owl:ObjectProperty .
      ?concept rdfs:subClassOf|owl:equivalentClass
        [ rdf:type owl:Restriction ;
          owl:onProperty ?objectProperty ;
          owl:maxCardinality|owl:cardinality ?cardinalityValue ].
    } GROUP BY ?individual ?concept
  }
  BIND(?resource AS ?individual)
  BIND(?class AS ?concept)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>objectProperty</em> is assigned a maximum cardinality of <em>cardinalityValue</em> for class <em>class</em>, <em>resource</em> <em>rdf:type</em> <em>class</em>, and <em>resource</em> has <em>objectCount</em> distinct assignments of <em>objectProperty</em> which is greater than <em>cardinalityValue</em>, we can conclude that there is an inconsistency associated with <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:DeadlySins rdf:type owl:Class ;
    rdfs:subClassOf sio:Collection ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasMember ;
            owl:maxCardinality &quot;7&quot;^^xsd:integer ] ; #Set to 8 instead of 7 to keep ontology consistent
    rdfs:label &quot;seven deadly sins&quot; .

val-kb:SevenDeadlySins rdf:type valo:DeadlySins ;
    sio:hasMember 
        val-kb:Pride ,
        val-kb:Envy ,
        val-kb:Gluttony ,
        val-kb:Greed ,
        val-kb:Lust ,
        val-kb:Sloth ,
        val-kb:Wrath ,
        val-kb:Redundancy .

val-kb:DistinctSinsRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        (val-kb:Pride 
        val-kb:Envy 
        val-kb:Gluttony 
        val-kb:Greed 
        val-kb:Lust 
        val-kb:Sloth 
        val-kb:Wrath 
        val-kb:Redundancy ) .
</code></pre><h5 id="data-max-cardinality">Data Max Cardinality</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ;
    ?dataProperty ?data .
  ?dataProperty rdf:type owl:DatatypeProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?dataProperty ;
      owl:maxCardinality ?cardinalityValue ] .
  {
    SELECT DISTINCT (COUNT(DISTINCT ?data) AS ?dataCount)
    WHERE 
    {
      ?resource rdf:type ?class ;
        ?dataProperty ?data .
      ?dataProperty rdf:type owl:DatatypeProperty .
      ?class rdfs:subClassOf|owl:equivalentClass
        [ rdf:type owl:Restriction ;
          owl:onProperty ?dataProperty ;
          owl:maxCardinality ?cardinalityValue ].
    }
  }
  FILTER(?dataCount &gt; ?cardinalityValue)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>datatypeProperty</em> is assigned a maximum cardinality of <em>cardinalityValue</em> for class <em>class</em>, <em>resource</em> <em>rdf:type</em> <em>class</em>, and <em>resource</em> has <em>dataCount</em> distinct assignments of <em>datatypeProperty</em> which is greater than <em>cardinalityValue</em>, we can conclude that there is an inconsistency associated with <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:hasAge rdf:type owl:DatatypeProperty ;
    rdfs:label &quot;has age&quot; ;
    rdfs:subPropertyOf sio:hasValue .

valo:Person rdf:type owl:Class ;
    rdfs:label &quot;person&quot; ;
    rdfs:subClassOf
        [ rdf:type owl:Restriction ;
            owl:onProperty valo:hasAge ;
            owl:maxCardinality &quot;1&quot;^^xsd:integer ] . 

val-kb:Katie rdf:type valo:Person ;
    rdfs:label &quot;Katie&quot; ;
    valo:hasAge &quot;31&quot;^^xsd:integer , &quot;34&quot;^^xsd:integer .
</code></pre><h5 id="object-max-qualified-cardinality">Object Max Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:hasComponentPart rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has component part&quot; .

sio:Triangle rdf:type owl:Class ;
    rdfs:subClassOf sio:Polygon ;
    dct:description &quot;A triangle is a polygon composed of three points and three line segments, in which each point is fully connected to another point along through the line segment.&quot; ;
    rdfs:label &quot;triangle&quot; .

sio:LineSegment rdf:type owl:Class ;
    rdfs:subClassOf sio:Line ;
    dct:description &quot;A line segment is a line and a part of a curve that is (inclusively) bounded by two terminal points.&quot; ;
    rdfs:label &quot;line segment&quot; .

sio:DirectedLineSegment rdf:type owl:Class ;
    rdfs:subClassOf sio:LineSegment ;
    dct:description &quot;A directed line segment is a line segment that is contained by an ordered pair of endpoints (a start point and an endpoint).&quot; ;
    rdfs:label &quot;directed line segment&quot; .

sio:ArrowedLineSegment rdf:type owl:Class ;
    rdfs:subClassOf sio:DirectedLineSegment ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasPart ;
            owl:someValuesFrom sio:Triangle ] ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasComponentPart ; 
            owl:maxQualifiedCardinality &quot;2&quot;^^xsd:nonNegativeInteger ;
            owl:onClass sio:Triangle ] ;
    dct:description &quot;An arrowed line is a directed line segment in which one or both endpoints is tangentially part of a triangle that bisects the line.&quot; ;
    rdfs:label &quot;arrowed line segment&quot; .

val-kb:TripleArrowLineSegment rdf:type sio:ArrowedLineSegment ;
    rdfs:label &quot;triple arrow line segment&quot; ;
    sio:hasComponentPart
        val-kb:LineSegment ,
        val-kb:FirstArrow ,
        val-kb:SecondArrow ,
        val-kb:ThirdArrow .

val-kb:FirstArrow rdf:type sio:Triangle ;
    rdfs:label &quot;first arrow&quot; .

val-kb:SecondArrow rdf:type sio:Triangle ;
    rdfs:label &quot;first arrow&quot; .

val-kb:ThirdArrow rdf:type sio:Triangle ;
    rdfs:label &quot;first arrow&quot; .

val-kb:LineSegment rdf:type sio:LineSegment ;
    rdfs:label &quot;line segment &quot; .
</code></pre><h5 id="data-max-qualified-cardinality">Data Max Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

sio:MathematicalEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    rdfs:label &quot;mathematical entity&quot; ;
    dct:description &quot;A mathematical entity is an information content entity that are components of a mathematical system or can be defined in mathematical terms.&quot; .

valo:hasPolynomialRoot rdf:type owl:DatatypeProperty ;
    rdfs:subPropertyOf sio:hasValue ;
    rdfs:label &quot;has polynomial root&quot; .

val-kb:QuadraticPolynomialRootRestriction rdf:type owl:Restriction ;
    owl:onProperty valo:hasPolynomialRoot ;
    owl:maxQualifiedCardinality &quot;2&quot;^^xsd:integer ;
    owl:onDataRange xsd:decimal .

val-kb:QuadraticPolynomialInstance rdf:type sio:ConceptualEntity ;
    rdfs:label &quot;quadratic polynomial instance&quot; ;
    valo:hasPolynomialRoot &quot;1.23&quot;^^xsd:decimal , &quot;3.45&quot;^^xsd:decimal , &quot;5.67&quot;^^xsd:decimal .
</code></pre><h4 id="min-cardinality">Min Cardinality</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\leq%20nP" alt="formula"></p>
<h5 id="object-min-cardinality">Object Min Cardinality</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?objectProperty [ rdf:type owl:Individual ] .
}
WHERE {
  ?resource rdf:type ?class ;
    ?objectProperty ?object .
  ?objectProperty rdf:type owl:ObjectProperty .
  ?class rdfs:subClassOf|owl:equivalentClass
    [ rdf:type owl:Restriction ;
      owl:onProperty ?objectProperty ;
      owl:minCardinality|owl:cardinality ?cardinalityValue ].
  FILTER(?objectCount &lt; ?cardinalityValue)
  {
    SELECT DISTINCT (COUNT(DISTINCT ?object) AS ?objectCount)
    WHERE 
    {
      ?resource rdf:type ?class ;
        ?objectProperty ?object .
      ?objectProperty rdf:type owl:ObjectProperty .
      ?class rdfs:subClassOf|owl:equivalentClass
        [ rdf:type owl:Restriction ;
          owl:onProperty ?objectProperty ;
          owl:minCardinality|owl:cardinality ?cardinalityValue ].
    }
  }
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>objectProperty</em> is assigned a minimum cardinality of <em>cardinalityValue</em> for class <em>class</em>, <em>resource</em> <em>rdf:type</em> <em>class</em>, and <em>resource</em> has <em>objectCount</em> distinct assignments of <em>objectProperty</em> which is less than <em>cardinalityValue</em>, we can conclude the existence of additional assignments of <em>objectProperty</em> for <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:StudyGroup rdf:type owl:Class ;
    rdfs:subClassOf sio:Collection ,
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasMember ;
            owl:minCardinality &quot;3&quot;^^xsd:integer ] ; 
    rdfs:label &quot;study group&quot; .

val-kb:StudyGroupInstance rdf:type valo:StudyGroup ;
    sio:hasMember 
        val-kb:Steve ,
        val-kb:Ali .

val-kb:Steve rdf:type sio:Human .
val-kb:Luis rdf:type sio:Human .
val-kb:Ali rdf:type sio:Human .

val-kb:DistinctStudentsRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        (val-kb:Steve 
        val-kb:Luis 
        val-kb:Ali ) .
</code></pre><h5 id="data-min-cardinality">Data Min Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource ?dataProperty [ rdf:type rdfs:Datatype ] .
}
WHERE {
  ?resource rdf:type ?class ;
    ?dataProperty ?data .
  ?dataProperty rdf:type owl:DatatypeProperty .
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Restriction ;
        owl:onProperty ?dataProperty ;
        owl:minCardinality ?cardinalityValue ] .
  {
    SELECT DISTINCT (COUNT(DISTINCT ?data) AS ?dataCount)
    WHERE 
    {
      ?resource rdf:type ?class ;
        ?dataProperty ?data .
      ?dataProperty rdf:type owl:DatatypeProperty .
      ?class rdf:type owl:Class ;
        rdfs:subClassOf|owl:equivalentClass
          [ rdf:type owl:Restriction ;
            owl:onProperty ?dataProperty ;
            owl:minCardinality ?cardinalityValue ].
    }
  }
  FILTER(?dataCount &lt; ?cardinalityValue)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>dataProperty</em> is assigned a minimum cardinality of <em>cardinalityValue</em> for class <em>class</em>, <em>resource</em> <em>rdf:type</em> <em>class</em>, and <em>resource</em> has <em>dataCount</em> distinct assignments of <em>dataProperty</em> which is less than <em>cardinalityValue</em>, we can conclude the existence of additional assignments of <em>dataProperty</em> for <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>valo:hasBirthYear rdf:type owl:DatatypeProperty ;
    rdfs:subPropertyOf sio:hasValue ;
    rdfs:label &quot;has birth year&quot; .

valo:Person rdf:type owl:Class ;
    rdfs:label &quot;person&quot; ;
    rdfs:subClassOf sio:Human ;
    rdfs:subClassOf
        [ rdf:type owl:Restriction ;
            owl:onProperty valo:hasBirthYear ;
            owl:cardinality &quot;1&quot;^^xsd:integer ] . 

val-kb:Erik rdf:type valo:Person ;
    rdfs:label &quot;Erik&quot; ;
    valo:hasBirthYear &quot;1988&quot;^^xsd:integer , &quot;1998&quot;^^xsd:integer .
</code></pre><h5 id="object-min-qualified-cardinality">Object Min Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:Polyline rdf:type owl:Class ;
    rdfs:subClassOf sio:GeometricEntity ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasComponentPart ; 
            owl:minQualifiedCardinality &quot;2&quot;^^xsd:nonNegativeInteger ;
            owl:onClass sio:LineSegment ] ;
    dct:description &quot;A polyline is a connected sequence of line segments.&quot; ;
    rdfs:label &quot;polyline&quot; .

val-kb:PolylineSegment rdf:type sio:Polyline ;
    rdfs:label &quot;polyline segment &quot; ;
    sio:hasComponentPart val-kb:LineSegmentInstance .

val-kb:LineSegmentInstance rdf:type sio:LineSegment ;
    rdfs:label &quot;line segment instance&quot; .
</code></pre><h5 id="data-min-qualified-cardinality">Data Min Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>valo:hasName rdf:type owl:DatatypeProperty ;
    rdfs:subPropertyOf sio:hasName ;
    rdfs:label &quot;has name&quot; .

val-kb:NameRestriction rdf:type owl:Restriction ;
    owl:onProperty valo:hasName ;
    owl:minQualifiedCardinality &quot;2&quot;^^xsd:integer ;
    owl:onDataRange xsd:string .

val-kb:Jackson rdf:type sio:Human ;
    rdfs:label &quot;Jackson&quot; ;
    valo:hasName &quot;Jackson&quot;^^xsd:string .
</code></pre><h4 id="exact-cardinality">Exact Cardinality</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math==nP" alt="formula"></p>
<h5 id="object-exact-cardinality">Object Exact Cardinality</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {

}
</code></pre><p>% Still need to check distinctness of object -- This is currently only accounting for max. Need to account for min as well<br><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>valo:Trio rdf:type owl:Class ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasMember ;
            owl:cardinality &quot;2&quot;^^xsd:integer
        ] .

val-kb:Stooges rdf:type valo:Trio ;
    sio:hasMember 
        val-kb:Larry ,
        val-kb:Moe ,
        val-kb:Curly .

val-kb:DistinctStoogesRestriction rdf:type owl:AllDifferent ;
    owl:distinctMembers
        ( val-kb:Larry 
        val-kb:Moe 
        val-kb:Curly ) .
</code></pre><h5 id="data-exact-cardinality">Data Exact Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {

}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><h5 id="object-exact-qualified-cardinality">Object Exact Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:hasComponentPart rdf:type owl:ObjectProperty ;
    rdfs:label &quot;has component part&quot; .

sio:PolygonEdge rdf:type owl:Class ;
    rdfs:subClassOf sio:LineSegment ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:isPartOf ;
            owl:someValuesFrom sio:Polygon ] ;
    rdfs:subClassOf 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:hasComponentPart ; 
            owl:qualifiedCardinality &quot;2&quot;^^xsd:nonNegativeInteger ;
            owl:onClass sio:PolygonVertex ] ;
    dct:description &quot;A polygon edge is a line segment joining two polygon vertices.&quot; ;
    rdfs:label &quot;polygon edge&quot; .

val-kb:TripleVertexedPolyEdge rdf:type sio:PolygonEdge ;
    rdfs:label &quot;triple vertexed polygon edge&quot; ;
    sio:hasComponentPart val-kb:VertexOne , val-kb:VertexTwo , val-kb:VertexThree .

val-kb:VertexOne rdf:type sio:PolygonVertex ;
    rdfs:label &quot;vertex one&quot; .

val-kb:VertexTwo rdf:type sio:PolygonVertex ;
    rdfs:label &quot;vertex two&quot; .

val-kb:VertexThree rdf:type sio:PolygonVertex ;
    rdfs:label &quot;vertex three&quot; .
</code></pre><h5 id="data-exact-qualified-cardinality">Data Exact Qualified Cardinality</h5>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
}
WHERE {
}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

valo:uniqueUsername rdf:type owl:DatatypeProperty ;
    rdfs:subPropertyOf sio:hasValue ;
    rdfs:label &quot;unique username&quot; .

val-kb:UsernameRestriction rdf:type owl:Restriction ;
    owl:onProperty valo:uniqueUsername ;
    owl:qualifiedCardinality &quot;1&quot;^^xsd:integer ;
    owl:onDataRange xsd:string .

val-kb:Steve rdf:type sio:Human ;
    rdfs:label &quot;Steve&quot; ;
    valo:uniqueUsername &quot;SteveTheGamer&quot;^^xsd:string , &quot;ScubaSteve508&quot;^^xsd:string .
</code></pre><h3 id="disjunction">Disjunction</h3>
<h4 id="object-union-of">Object Union Of</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C_1%20\sqcup%20\dots%20\sqcup%20C_n" alt="formula"></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member rdfs:subClassOf ?resource .
}
WHERE {
  ?resource rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Class ;
        owl:unionOf ?list ] .
  ?list rdf:rest*/rdf:first ?member .
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since the class <em>resource</em> has a subclass or equivalent class relation with a class that comprises the union of <em>list</em>, which contains member <em>member</em>, we can infer that <em>member</em> is a subclass of <em>resource</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
#    rdfs:subClassOf rdf:nodeID=&quot;arc0158b21&quot; ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

sio:GeometricEntity rdf:type owl:Class ;
    rdfs:label &quot;geometric entity&quot; ;
    rdfs:subClassOf sio:InformationContentEntity ;
    dct:description &quot;A geometric entity is an information content entity that pertains to the structure and topology of a space.&quot; .

sio:Curve rdf:type owl:Class ;
    rdfs:label &quot;curve&quot; ;
    rdfs:subClassOf sio:GeometricEntity ;
    dct:description &quot;A curve is a geometric entity that may be located in n-dimensional spatial region whose extension may be n-dimensional,  is composed of at least two fully connected points and does not intersect itself.&quot; .

sio:Line rdf:type owl:Class ;
    rdfs:subClassOf sio:Curve ;
    rdfs:label &quot;line&quot; ;
    owl:equivalentClass 
        [   rdf:type owl:Class ;
            owl:unionOf ( sio:LineSegment sio:Ray sio:InfiniteLine ) ] ;
    dct:description &quot;A line is curve that extends in a single dimension (e.g. straight line; exhibits no curvature), and is composed of at least two fully connected points.&quot; .
</code></pre><p>A reasoner should infer <code>sio:LineSegment rdfs:subClassOf sio:Line . sio:Ray rdfs:subClassOf sio:Line . sio:InfiniteLine rdfs:subClassOf sio:Line .</code></p>
<h4 id="data-union-of">Data Union Of</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?class .
}
WHERE {
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Class ;
        owl:unionOf ?list ] .
  ?list rdf:rest*/rdf:first ?member .
  ?member rdf:type owl:Restriction ;
    owl:onProperty ?dataProperty ;
    owl:someValuesFrom ?datatype . 
  ?dataProperty rdf:type owl:DatatypeProperty .
  ?resource ?dataProperty ?data .
  FILTER(DATATYPE(?data)=?datatype)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> has a subclass or equivalent class relationship to the union of <em>list</em> which has members <em>member</em>, and <em>member</em> is a restriction on <em>dataProperty</em> to have some values from <em>datatype</em>, we can infer <em>resource</em> <em>rdf:type</em> <em>class</em>, since <em>resource</em> <em>dataProperty</em> <em>data</em> and the datatype of <em>data</em> is <em>datatype</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

sio:MathematicalEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    rdfs:label &quot;mathematical entity&quot; ;
    dct:description &quot;A mathematical entity is an information content entity that are components of a mathematical system or can be defined in mathematical terms.&quot; .

sio:Number rdf:type owl:Class ;
    rdfs:label &quot;number&quot; ;
    rdfs:subClassOf sio:MathematicalEntity ;
    dct:description &quot;A number is a mathematical object used to count, label, and measure.&quot; .

sio:MeasurementValue rdf:type owl:Class ;
    rdfs:label &quot;measurement value&quot; ;
    rdfs:subClassOf sio:Number ;
    rdfs:subClassOf 
        [ rdf:type owl:Class ;
            owl:unionOf ( 
                [ rdf:type owl:Restriction ; 
                    owl:onProperty sio:hasValue ;
                    owl:someValuesFrom xsd:dateTime ] 
                [ rdf:type owl:Restriction ; 
                    owl:onProperty sio:hasValue ;
                    owl:someValuesFrom xsd:double ]
                [ rdf:type owl:Restriction ; 
                    owl:onProperty sio:hasValue ;
                    owl:someValuesFrom xsd:float ]
                [ rdf:type owl:Restriction ; 
                    owl:onProperty sio:hasValue ;
                    owl:someValuesFrom xsd:integer ]
            ) ] ;
    dct:description &quot;A measurement value is a quantitative description that reflects the magnitude of some attribute.&quot; .

val-kb:DateTimeMeasurement rdf:type owl:Individual ;
    rdfs:label &quot;date time measurement&quot; ;
    sio:hasValue &quot;10141990&quot;^^xsd:dateTime .

val-kb:IntegerMeasurement rdf:type owl:Individual ;
    rdfs:label &quot;integer measurement&quot; ;
    sio:hasValue &quot;12&quot;^^xsd:integer .

val-kb:DoubleMeasurement rdf:type owl:Individual ;
    rdfs:label &quot;double measurement&quot; ;
    sio:hasValue &quot;6.34&quot;^^xsd:double .

val-kb:FloatMeasurement rdf:type owl:Individual ;
    rdfs:label &quot;float measurement&quot; ;
    sio:hasValue &quot;3.14&quot;^^xsd:float .
</code></pre><p>A reasoner should infer <code>val-kb:DateTimeMeasurement rdf:type sio:MeasurementValue . val-kb:IntegerMeasurement rdf:type sio:MeasurementValue . val-kb:DoubleMeasurement rdf:type sio:MeasurementValue . val-kb:FloatMeasurement rdf:type sio:MeasurementValue .</code></p>
<h4 id="disjoint-union">Disjoint Union</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?member rdfs:subClassOf ?resource ;
    owl:disjointWith ?item .
}
WHERE {
  ?resource rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Class ;
        owl:disjointUnionOf ?list ] .
  ?list rdf:rest*/rdf:first ?member .
  {
    SELECT DISTINCT ?item ?class WHERE 
    {
      ?class rdf:type owl:Class ;
        rdfs:subClassOf|owl:equivalentClass
          [ rdf:type owl:Class ;
            owl:disjointUnionOf ?list ] .
      ?list rdf:rest*/rdf:first ?item .
    }
  }
  FILTER(?resource = ?class)
  FILTER(?member != ?item)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since the class <em>resource</em> has a subclass or equivalent class relation with a class that comprises the disjoint union of <em>list</em>, which contains member <em>member</em>, we can infer that <em>member</em> is a subclass of <em>resource</em> and disjoint with the other members of the list.</p>
<p><strong>Example</strong></p>
<pre><code>sio:BiologicalEntity  rdf:type owl:Class ;
    rdfs:label &quot;biological entity&quot; ;
    rdfs:subClassOf sio:HeterogeneousSubstance ;
    dct:description &quot;A biological entity is a heterogeneous substance that contains genomic material or is the product of a biological process.&quot; .

sio:HeterogeneousSubstance  rdf:type owl:Class ;
    rdfs:label &quot;heterogeneous substance&quot; ;
    rdfs:subClassOf sio:MaterialEntity ;
    rdfs:subClassOf sio:ChemicalEntity ;
    dct:description &quot;A heterogeneous substance is a chemical substance that is composed of more than one different kind of component.&quot; .

sio:MaterialEntity  rdf:type owl:Class ;
    rdfs:label &quot;material entity&quot; ;
    rdfs:subClassOf sio:Object ;
    dct:description &quot;A material entity is a physical entity that is spatially extended, exists as a whole at any point in time and has mass.&quot; .

sio:ChemicalEntity  rdf:type owl:Class ;
    rdfs:label &quot;chemical entity&quot; ;
    rdfs:subClassOf sio:MaterialEntity ;
    dct:description &quot;A chemical entity is a material entity that pertains to chemistry.&quot; .

valo:Lobe rdf:type owl:Class ;
    rdfs:subClassOf sio:BiologicalEntity ;
    rdfs:label &quot;lobe&quot; ;
    dct:description &quot;A lobe that is part the brain.&quot; ;
    owl:equivalentClass 
        [ rdf:type owl:Class ;
            owl:disjointUnionOf ( valo:FrontalLobe valo:ParietalLobe valo:TemporalLobe valo:OccipitalLobe valo:LimbicLobe ) ] .
</code></pre><p>A reasoner should infer</p>
<pre><code>valo:FrontalLobe rdfs:subClassOf valo:Lobe ;
    owl:disjointWith ex:ParietalLobe , valo:TemporalLobe , valo:OccipitalLobe , valo:LimbicLobe .

valo:ParietalLobe rdfs:subClassOf valo:Lobe ;
    owl:disjointWith valo:FrontalLobe , valo:TemporalLobe , valo:OccipitalLobe , valo:LimbicLobe .

valo:TemporalLobe rdfs:subClassOf valo:Lobe ;
    owl:disjointWith valo:FrontalLobe , valo:ParietalLobe , valo:OccipitalLobe , valo:LimbicLobe .

valo:OccipitalLobe rdfs:subClassOf ex:Lobe ;
    owl:disjointWith valo:FrontalLobe , valo:ParietalLobe , valo:TemporalLobe , valo:LimbicLobe .

valo:LimbicLobe rdfs:subClassOf valo:Lobe ;
    owl:disjointWith valo:FrontalLobe , valo:ParietalLobe , valo:TemporalLobe , valo:OccipitalLobe .
</code></pre><h3 id="intersection">Intersection</h3>
<h4 id="object-intersection-of">Object Intersection Of</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C_1%20\sqcap%20\dots%20\sqcap%20C_n" alt="formula"><br><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type ?class.
}
WHERE {
  ?class rdf:type owl:Class ;
    owl:intersectionOf ?list .
  ?list rdf:rest*/rdf:first ?member .
  {
    ?member rdf:type owl:Class .
    ?resource rdf:type ?member .
  }
  UNION 
  {
    ?member rdf:type owl:Restriction ;
      owl:onProperty ?objectProperty ;
      owl:someValuesFrom ?restrictedClass .
    ?objectProperty rdf:type owl:ObjectProperty .
    ?resource ?objectProperty [rdf:type  ?restrictedClass ] .
  }
  {
    SELECT DISTINCT * WHERE
    {
      ?concept rdf:type owl:Class ;
        owl:intersectionOf ?list .
      ?list rdf:rest*/rdf:first ?item .
      {
        ?item rdf:type owl:Class .
        ?individual rdf:type ?item .
      }
      UNION
      {
        ?item rdf:type owl:Restriction ;
          owl:onProperty ?objectProperty ;
          owl:someValuesFrom ?restrictedClass .
        ?objectProperty rdf:type owl:ObjectProperty .
        ?individual ?objectProperty [rdf:type  ?restrictedClass ] .
      }
    }
  }
  BIND(?class AS ?concept) 
  BIND(?resource AS ?individual) 
  FILTER(?member != ?item)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is the intersection of the the members in <em>list</em>, and <em>resource</em> is of type each of the members in the list, then we can infer <em>resource</em> is a <em>class</em>.</p>
<p><strong>Example</strong></p>
<pre><code>sio:Molecule rdf:type owl:Class ;
    rdfs:label &quot;molecule&quot; .

sio:isTargetIn rdf:type owl:ObjectProperty ;
    rdfs:label &quot;is target in&quot; .

sio:Target rdf:type owl:Class  ;
    owl:intersectionOf ( 
        sio:Molecule 
        [ rdf:type owl:Restriction ;
            owl:onProperty sio:isTargetIn ;
            owl:someValuesFrom sio:Process ] ) ;
    rdfs:label &quot;target&quot; .

val-kb:ProteinReceptor rdf:type sio:Molecule ;
    rdfs:label &quot;protein receptor&quot; ;
    sio:isTargetIn val-kb:Therapy .

val-kb:Therapy rdf:type sio:Process ;
    rdfs:label &quot;therapy&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:ProteinReceptor rdf:type sio:Target .</code></p>
<pre><code>val-kb:Brian rdf:type valo:CanTalk , valo:Dog , valo:Friendly .

valo:CanTalk rdf:type owl:Class .
valo:Dog rdf:type owl:Class .
valo:Friendly rdf:type owl:Class .

valo:FriendlyTalkingDog rdf:type owl:Class ;
    owl:intersectionOf (valo:CanTalk valo:Dog valo:Friendly) .
</code></pre><p>A reasoner should infer <code>val-kb:Brian rdf:type valo:FriendlyTalkingDog .</code></p>
<h4 id="data-intersection-of">Data Intersection Of</h4>
<p><strong>Axiom</strong></p>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {

}
WHERE {

}
</code></pre><p><strong>Explanation</strong></p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><h3 id="negation">Negation</h3>
<h4 id="complement-of">Complement Of</h4>
<p><strong>Axiom</strong></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\neg%20C" alt="formula"></p>
<h5 id="object-complement-of">Object Complement Of</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?resource rdf:type ?class ,
      ?complementClass .
  ?class rdf:type owl:Class .
  ?complementClass rdf:type owl:Class .
  {?class owl:complementOf ?complementClass .} 
    UNION 
  {?complementClass owl:complementOf ?class .}
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> and <em>complementClass</em> are complementary, <em>resource</em> being of type both <em>class</em> and <em>complementClass</em> leads to an inconsistency.</p>
<p><strong>Example</strong></p>
<pre><code>valo:VitalStatus rdfs:subClassOf sio:Attribute ;
    rdfs:label &quot;vital status&quot; .

valo:Dead rdf:type owl:Class ;
    rdfs:subClassOf valo:VitalStatus ;
    rdfs:label &quot;dead&quot; .

valo:Alive rdf:type owl:Class ;
    rdfs:subClassOf valo:VitalStatus ;
    rdfs:label &quot;alive&quot; ;
    owl:complementOf valo:Dead .

val-kb:VitalStatusOfPat rdf:type valo:Alive , valo:Dead ;
    rdfs:label &quot;Pat&#39;s Vital Status&quot; ;
    sio:isAttributeOf val-kb:Pat .

val-kb:Pat rdf:type sio:Human ;
    rdfs:label &quot;Pat&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:VitalStatusOfPat rdf:type owl:Nothing</code> or that an inconsistency occurs.</p>
<h5 id="data-complement-of">Data Complement Of</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?datatype rdf:type rdfs:Datatype ;
    owl:datatypeComplementOf ?complement .
  ?resource ?dataProperty ?value .
  ?dataProperty rdf:type owl:DatatypeProperty ;
    rdfs:range ?datatype .
  FILTER(DATATYPE(?value) = ?complement)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>datatype</em> is the complement of <em>complement</em>, <em>dataProperty</em> has range <em>datatype</em>, and <em>resource</em> <em>dataProperty</em> <em>value</em>, but <em>value</em> is of type <em>complement</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>
</code></pre><h5 id="object-property-complement-of">Object Property Complement Of</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Class ;
        owl:complementOf 
          [ rdf:type owl:Restriction ;
            owl:onProperty ?objectProperty ;
            owl:someValuesFrom ?restrictedClass ] 
      ] .
  ?resource rdf:type ?class ;
    ?objectProperty [ rdf:type ?objectClass ] .
  ?objectProperty rdf:type owl:ObjectProperty .
  {
    FILTER(?objectClass = ?restrictedClass)
  }
  UNION
  {
    ?objectClass rdfs:subClassOf*|owl:equivalentClass ?restrictedClass . 
  }
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>class</em> is a subclass of or is equivalent to a class with a complement restriction on the use of <em>objectProperty</em> to have values from <em>restrictedClass</em>, and <em>resource</em> is of type <em>class</em>, but has the link <em>objectProperty</em> to have values from an instance of <em>restrictedClass</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasUnit rdf:type owl:ObjectProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has unit&quot; ;
    owl:inverseOf sio:isUnitOf ;
    rdfs:range sio:UnitOfMeasurement ;
    rdfs:subPropertyOf sio:hasAttribute ;
    dct:description &quot;has unit is a relation between a quantity and the unit it is a multiple of.&quot; .

sio:DimensionlessQuantity rdf:type owl:Class ;
    rdfs:label &quot;dimensionless quantity&quot; ;
    rdfs:subClassOf sio:Quantity ,
        [ rdf:type owl:Class ;
            owl:complementOf [ rdf:type owl:Restriction ;
                owl:onProperty sio:hasUnit ;
                owl:someValuesFrom sio:UnitOfMeasurement ] ];
    owl:disjointWith sio:DimensionalQuantity ;
    dct:description &quot;A dimensionless quantity is a quantity that has no associated unit.&quot; .

sio:Quantity rdf:type owl:Class ;
    rdfs:label &quot;quantity&quot; ;
    owl:equivalentClass 
        [ rdf:type owl:Class ; 
            owl:unionOf (sio:DimensionlessQuantity sio:DimensionalQuantity) ] ;
    rdfs:subClassOf sio:MeasurementValue ;
    dct:description &quot;A quantity is an informational entity that gives the magnitude of a property.&quot; .

sio:MeasurementValue rdf:type owl:Class ;
    rdfs:label &quot;measurement value&quot; ;
    rdfs:subClassOf sio:Number ;
    dct:description &quot;A measurement value is a quantitative description that reflects the magnitude of some attribute.&quot; .

sio:Number rdf:type owl:Class ;
    rdfs:label &quot;number&quot; ;
    rdfs:subClassOf sio:MathematicalEntity ;
    dct:description &quot;A number is a mathematical object used to count, label, and measure.&quot; .

sio:MathematicalEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:InformationContentEntity ;
    rdfs:label &quot;mathematical entity&quot; ;
    dct:description &quot;A mathematical entity is an information content entity that are components of a mathematical system or can be defined in mathematical terms.&quot; .

sio:InformationContentEntity rdf:type owl:Class ;
    rdfs:subClassOf sio:Object ;
    rdfs:label &quot;information content entity&quot; ;
    dct:description &quot;An information content entity is an object that requires some background knowledge or procedure to correctly interpret.&quot; .

val-kb:Efficiency rdf:type sio:DimensionlessQuantity  ;
    sio:hasUnit [ rdf:type valo:Percentage ] ;
    rdfs:label &quot;efficiency&quot; .

valo:Percentage rdfs:subClassOf sio:UnitOfMeasurement ;
    rdfs:label &quot;percentage&quot; .
</code></pre><p>A reasoner should infer <code>val-kb:Efficiency rdf:type owl:Nothing .</code></p>
<h5 id="data-property-complement-of">Data Property Complement Of</h5>
<p><strong>Query</strong></p>
<pre><code>CONSTRUCT {
  ?resource rdf:type owl:Nothing .
}
WHERE {
  ?class rdf:type owl:Class ;
    rdfs:subClassOf|owl:equivalentClass
      [ rdf:type owl:Class ;
        owl:complementOf 
          [ rdf:type owl:Restriction ;
            owl:onProperty ?dataProperty ;
            owl:someValuesFrom ?datatype ] 
      ] .
  ?resource rdf:type ?class ;
    ?dataProperty ?value .
  ?dataProperty rdf:type owl:DatatypeProperty .
  FILTER(DATATYPE(?value)=?datatype)
}
</code></pre><p><strong>Explanation</strong></p>
<p>Since <em>resource</em> is a <em>class</em> which is equivalent to or a subclass of a class that has a complement of restriction on <em>dataProperty</em> to have some values from <em>datatype</em>, <em>resource</em> <em>dataProperty</em> <em>value</em>, but <em>value</em> has a datatype <em>datatype</em>, an inconsistency occurs.</p>
<p><strong>Example</strong></p>
<pre><code>sio:hasValue rdf:type owl:DatatypeProperty ,
                                owl:FunctionalProperty;
    rdfs:label &quot;has value&quot; ;
    dct:description &quot;A relation between a informational entity and its actual value (numeric, date, text, etc).&quot; .

val:NumericalValue rdf:type owl:Class ;
    rdfs:label &quot;numerical value&quot; ;
    rdfs:subClassOf sio:ConceptualEntity ;
    rdfs:subClassOf
        [ rdf:type owl:Class ;
            owl:complementOf 
                [ rdf:type owl:Restriction ;
                    owl:onProperty sio:hasValue ;
                    owl:someValuesFrom xsd:string ] 
        ] .

val-kb:Number rdf:type val:NumericalValue ;
    sio:hasValue &quot;Fifty&quot;^^xsd:string .
</code></pre><p>A reasoner should infer <code>val-kb:Number rdf:type owl:Nothing .</code></p>
<h3 id="code">Code</h3>
<h4 id="deductor-agent">Deductor Agent</h4>
<pre><code class="lang-python">class Deductor(GlobalChangeService):
    def __init__(self, reference, antecedent, consequent, explanation, resource=&quot;?resource&quot;, prefixes=None): 
        if resource is not None:
            self.resource = resource
        self.prefixes = {}
        if prefixes is not None:
            self.prefixes = prefixes
        self.reference = reference
        self.antecedent = antecedent
        self.consequent = consequent
        self.explanation = explanation

    def getInputClass(self):
        return pv.File

    def getOutputClass(self):
        return whyis.InferencedOver

    def get_query(self):
        self.app.db.store.nsBindings = {}
        return &#39;&#39;&#39;SELECT DISTINCT %s WHERE {\n%s \nFILTER NOT EXISTS {\n%s\n\t}\n}&#39;&#39;&#39; % (
        self.resource, self.antecedent, self.consequent)

    def get_context(self, i):
        context = {}
        context_vars = self.app.db.query(&#39;&#39;&#39;SELECT DISTINCT * WHERE {\n%s \nFILTER(regex(str(%s), &quot;^(%s)&quot;)) . }&#39;&#39;&#39; % (
        self.antecedent, self.resource, i.identifier), initNs=self.prefixes)
        for key in context_vars.vars :
            context[key] = context_vars.bindings[0][key]
        return context

    def process(self, i, o):
        for profile in self.app.config[&quot;active_profiles&quot;] :
            if self.reference in self.app.config[&quot;reasoning_profiles&quot;][profile] :
                npub = Nanopublication(store=o.graph.store)
                triples = self.app.db.query(
                    &#39;&#39;&#39;CONSTRUCT {\n%s\n} WHERE {\n%s \nFILTER NOT EXISTS {\n%s\n\t}\nFILTER (regex(str(%s), &quot;^(%s)&quot;)) .\n}&#39;&#39;&#39; % (
                    self.consequent, self.antecedent, self.consequent, self.resource, i.identifier), initNs=self.prefixes)
                try :
                    for s, p, o in triples:
                        print(&quot;Deductor Adding &quot;, s, p, o)
                        npub.assertion.add((s, p, o))
                except :
                    for s, p, o, c in triples:
                        print(&quot;Deductor Adding &quot;, s, p, o)
                        npub.assertion.add((s, p, o))                
                npub.provenance.add((npub.assertion.identifier, prov.value,
                                     rdflib.Literal(flask.render_template_string(self.explanation, **self.get_context(i)))))
</code></pre>
<h4 id="backtracer-agent">Backtracer Agent</h4>
<pre><code class="lang-python">class BackTracer(GlobalChangeService):
    def __init__(self, reference, antecedent, consequent, explanation, resource=&quot;?resource&quot;, prefixes=None): 
        if resource is not None:
            self.resource = resource
        self.prefixes = {}
        if prefixes is not None:
            self.prefixes = prefixes
        self.reference = reference
        self.antecedent = antecedent
        self.consequent = consequent
        self.explanation = explanation

    def getInputClass(self):
        return pv.File
    def getOutputClass(self):
        return whyis.InferencedOver

    def get_query(self):
        self.app.db.store.nsBindings = {}
        return &#39;&#39;&#39;PREFIX whyis: &lt;http://vocab.rpi.edu/whyis/&gt; SELECT DISTINCT %s WHERE {\n%s GRAPH ?g { %s }\nFILTER NOT EXISTS {\n ?g whyis:hypothesis &quot;%s&quot; \n\t}\n}&#39;&#39;&#39; % (
        self.resource, self.antecedent, self.consequent, self.reference)

    def get_context(self, i):
        context = {}
        context_vars = self.app.db.query(&#39;&#39;&#39;SELECT DISTINCT * WHERE {\n%s \nFILTER(regex(str(%s), &quot;^(%s)&quot;)) . }&#39;&#39;&#39; % (
        self.antecedent, self.resource, i.identifier), initNs=self.prefixes)
        for key in context_vars.vars :
            context[key] = context_vars.bindings[0][key]
        return context

    def process(self, i, o):
        for profile in self.app.config[&quot;active_profiles&quot;] :
            if self.reference in self.app.config[&quot;reasoning_profiles&quot;][profile] :
                npub = Nanopublication(store=o.graph.store)
                triples = self.app.db.query(
                    &#39;&#39;&#39;PREFIX whyis: &lt;http://vocab.rpi.edu/whyis/&gt; CONSTRUCT {\n?g whyis:hypothesis &quot;%s&quot; . \n} WHERE {\n%s GRAPH ?g { %s } \nFILTER NOT EXISTS {\n?g whyis:hypothesis &quot;%s&quot; \n\t}\nFILTER (regex(str(%s), &quot;^(%s)&quot;)) .\n}&#39;&#39;&#39; % (
                    self.reference, self.antecedent, self.consequent, self.reference, self.resource, i.identifier), initNs=self.prefixes)
                try :
                    for s, p, o in triples:
                        print(&quot;BackTracer Adding &quot;, s, p, o)
                        npub.assertion.add((s, p, o))
                except :
                    for s, p, o, c in triples:
                        print(&quot;BackTracer Adding &quot;, s, p, o)
                        npub.assertion.add((s, p, o))
</code></pre>
<h3 id="support-or-contact">Support or Contact</h3>
<p>Contact us at <a href="mailto:rashis2@rpi.edu">rashis2@rpi.edu</a>.</p>
